<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[破船之家]]></title>
  <link href="http://BeyondVincent.github.io/atom.xml" rel="self"/>
  <link href="http://BeyondVincent.github.io/"/>
  <updated>2013-08-02T01:27:43+08:00</updated>
  <id>http://BeyondVincent.github.io/</id>
  <author>
    <name><![CDATA[破船(BeyondVincent)]]></name>
    <email><![CDATA[beyondvincent@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[你好！github页面]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/27/107-hello-page-of-github/"/>
    <updated>2013-07-27T14:44:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/27/107-hello-page-of-github</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/07/octopress.jpg"></p>

<h3>大家好，我是破船！欢迎大家关注我的小站！</h3>

<p>我写博文经历了这些平台：
百度空间-><a href="http://www.devdiv.com/home.php?mod=space&amp;uid=12&amp;do=blog&amp;view=me&amp;from=space"><code>devdiv</code></a>><a href="http://blog.sina.com.cn/beyondvincent"><code>新浪博客</code></a>&ndash;><a href="http://blog.csdn.net/beyondvincent"><code>CSDN</code></a>&ndash;><code>wordpress</code>&ndash;><code>octopress</code>(现在)</p>

<!--more-->


<p>用wordpress搭建的博客，用了4个月，由于有好多麻烦事(备份、空间和流量等各种不爽)，现在果断在github上配合octopress搭建一个博客。</p>

<p>由于<code>git</code>和<a href="http://en.wikipedia.org/wiki/Markdown"><code>markdown</code></a>对我来说就是小白，所以搭建的时间断断续续持续了约一周。其实网上已经有很好的参考资料了，只要照着弄，很容易就能搭建好的。</p>

<p>这篇文章是第一篇，我用的markdown编辑器是<a href="http://mouapp.com/"><code>Mou</code></a>，感觉不错。</p>

<p>下面是一些在mac机器上用octopress写博文需要用到的操作(持续更新)</p>

<h3>目录</h3>

<ul>
<li>发表并部署博文</li>
<li>添加多说评论功能</li>
<li>起草文章 暂不公开</li>
<li>域名解析</li>
</ul>


<h3>发表并部署博文</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rake new_post["New Post"]
</span><span class='line'>$ rake generate
</span><span class='line'>$ git add .
</span><span class='line'>$ git commit -am "Some comment here." 
</span><span class='line'>$ git push origin source
</span><span class='line'>$ rake deploy</span></code></pre></td></tr></table></div></figure>


<h3>添加多说评论功能</h3>

<h4>A 获取<code>short_name</code></h4>

<p>去多说网注册账号，获取站点的short_name</p>

<h4>B 在<code>_config.yml</code>文件中添加如下内容</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># duoshuo comments
</span><span class='line'>duoshuo_comments: true
</span><span class='line'>duoshuo_short_name: yourname</span></code></pre></td></tr></table></div></figure>


<h4>C 在<code>source/_layouts/post.html</code>中添加多说评论模块</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>｛% if site.duoshuo_short_name and site.duoshuo_comments == true and page.comments == true %｝
</span><span class='line'>  &lt;section&gt;
</span><span class='line'>    &lt;h1&gt;Comments&lt;/h1&gt;
</span><span class='line'>    &lt;div id="comments" aria-live="polite"&gt;｛% include post/duoshuo1.html %｝&lt;/div&gt;
</span><span class='line'>  &lt;/section&gt;
</span><span class='line'>｛% endif %｝</span></code></pre></td></tr></table></div></figure>


<h4>D 创建<code>source/_includes/post/duoshuo.html</code>，并填入如下内容</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!-- Duoshuo Comment BEGIN --&gt;
</span><span class='line'>&lt;div class="ds-thread"&gt;&lt;/div&gt;
</span><span class='line'>&lt;script type="text/javascript"&gt;
</span><span class='line'>  var duoshuoQuery = {short_name:"beyondvincent"};
</span><span class='line'>  (function() {
</span><span class='line'>    var ds = document.createElement('script');
</span><span class='line'>    ds.type = 'text/javascript';ds.async = true;
</span><span class='line'>    ds.src = 'http://static.duoshuo.com/embed.js';
</span><span class='line'>    ds.charset = 'UTF-8';
</span><span class='line'>    (document.getElementsByTagName('head')[0] 
</span><span class='line'>    || document.getElementsByTagName('body')[0]).appendChild(ds);
</span><span class='line'>  })();
</span><span class='line'>&lt;/script&gt;
</span><span class='line'>&lt;!-- Duoshuo Comment END --&gt;</span></code></pre></td></tr></table></div></figure>


<h4>E 发布到站点</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rake generate
</span><span class='line'>$ git add .
</span><span class='line'>$ git commit -am "添加多说评论" 
</span><span class='line'>$ git push origin source
</span><span class='line'>$ rake deploy</span></code></pre></td></tr></table></div></figure>


<h3>起草文章暂不公开</h3>

<p>在文章头部添加<code>published: false</code>，就能起到暂时不公开文章了(即使已经部署到了github中)，要公开文章只需要将false修改<code>true</code>即可。</p>

<h3>域名解析</h3>

<p>我们可以给GitHub上的page指定一个域名，具体做法如下2个步骤</p>

<h4>1、给repo配置域名</h4>

<p>在<code>source</code>根目录下新建一个名为CNAME的文件，并把你的域名填写进去，例如<code>beyondvincent.com</code>。这样做的目的是告诉GitHub服务器开始将repo中的page(例如<code>beyondvincent.github.io</code>)指向到某个域名中。</p>

<h4>2、配置DNS(我的域名是在godaddy上购买的)</h4>

<p>添加一条A记录：
<code>@  204.232.175.78</code>
在CNAME中添加一条记录：
<code>http   beyondvincent.github.com</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac和iOS开发资源汇总—更新于2013-07-19]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/18/106/"/>
    <updated>2013-07-18T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/18/106</id>
    <content type="html"><![CDATA[<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/1U55JG9-0.jpg"><img class="alignnone size-full wp-image-1661" alt="1U55JG9-0" src="http://beyondvincent.com/wp-content/uploads/2013/07/1U55JG9-0.jpg" width="590" height="578" /></a></p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>本文主要汇集一些苹果开发的资源，会经常更新，建议大家把这篇文章单独收藏(在浏览器中按<strong><span style="color: #339966;">command+D</span></strong>)。</p>

<!--more-->


<p>今天(2013年7月19日)收录了许多中文网站和博客。大家一定要去感受一下哦。</p>

<p>如果大家有知道不错的站点，可以告诉我。</p>

<p>&nbsp;</p>

<h2><strong><span style="color: #339966;">目录</span></strong></h2>

<p><strong><span style="color: #339966;">1、苹果官方文档</span></strong><br/>
<strong><span style="color: #339966;"> 2、邮件列表</span></strong><br/>
<strong><span style="color: #339966;"> 3、论坛</span></strong><br/>
<strong><span style="color: #339966;"> 4、网站</span></strong><br/>
<strong><span style="color: #339966;"> 5、博客</span></strong><br/>
<strong><span style="color: #339966;"> 6、大会</span></strong><br/>
<strong><span style="color: #339966;"> 7、播客和录像</span></strong></p>

<h3><strong><span style="color: #339966;">正文</span></strong></h3>

<h2><strong><span style="color: #339966;">1、苹果官方文档</span></strong></h2>

<p>构建iOS程序：下面的这篇文章介绍了 iOS 程序开发的过程：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://developer.apple.com/library/ios/#referencelibrary/GettingStarted/RoadMapiOS/chapters/RM_YourFirstApp_iOS/Articles/01_CreatingProject.html" target="_blank"><span style="color: #339966; text-decoration: underline;">Start Developing iOS Apps Today</span></a></span></span></strong></p>

<p>构建Mac OS X程序：下面这篇文章介绍了Mac OS X开发的过程：<br/>
<span style="color: #339966;"><strong><span style="text-decoration: underline;"><span style="text-decoration: underline;"><a href="https://developer.apple.com/library/mac/#referencelibrary/GettingStarted/RoadMapOSX/chapters/01_Introduction.html" target="_blank"><span style="color: #339966; text-decoration: underline;">Start Developing Mac Apps Today</span></a></span></span></strong></span></p>

<p>Objective-C：下面的这个链接是苹果官方介绍Objective-C的文档：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html" target="_blank"><span style="color: #339966; text-decoration: underline;">Programming with Objective-C</span></a></span></span></strong></p>

<p>Xcode：下面这个链接是苹果官方介绍Xcode用户指南。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://developer.apple.com/library/mac/#documentation/ToolsLanguages/Conceptual/Xcode_User_Guide/000-About_Xcode/about.html" target="_blank"><span style="color: #339966; text-decoration: underline;">Xcode User Guide</span></a></span></span></strong></p>

<h2></h2>

<h2><strong><span style="color: #339966;">2、邮件列表</span></strong></h2>

<p>Cocoa-dev：由苹果负责运维，最初内容是与Mac OS X 中的Cocoa相关，目前在这个list上的许多开发者可以帮助你解决 iOS 相关问题（提问的时候最好先搜索一下，之前是否有人提问过相关问题）。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://lists.apple.com/mailman/listinfo/cocoa-dev" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="https://lists.apple.com/mailman/listinfo/cocoa-dev">https://lists.apple.com/mailman/listinfo/cocoa-dev</a></span></a></span></span></strong></p>

<p>Xcode-user：由苹果负责运维，该邮件列表是跟Xcode相关：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://lists.apple.com/mailman/listinfo/xcode-users" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="https://lists.apple.com/mailman/listinfo/xcode-users%C2%A0">https://lists.apple.com/mailman/listinfo/xcode-users%C2%A0</a></span></a></span></span></strong></p>

<p>Quartz-dev： 有苹果负责运维，该邮件列表主要是讨论Quartz 2D和Core Graphics相关技术：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://lists.apple.com/mailman/listinfo/quartz-dev" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://lists.apple.com/mailman/listinfo/quartz-dev">http://lists.apple.com/mailman/listinfo/quartz-dev</a></span></a></span></span></strong></p>

<p>iPhone SDK开发：这是第三方的一个邮件列表，主要讨论 iOS 开发。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://groups.google.com/group/iphonesdkdevelopment" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://groups.google.com/group/iphonesdkdevelopment">http://groups.google.com/group/iphonesdkdevelopment</a></span></a></span></span></strong></p>

<p>&nbsp;</p>

<h2><strong><span style="color: #339966;">3、论坛</span></strong></h2>

<p><strong><span style="color: #ff0000;">英文</span></strong></p>

<p>Learn Cocoa Forum：该论坛是书籍Learn cocoa on the Mac and Beginning iOS Development的官方论坛。活跃度非常不错，有初学者，也有经验丰富的开发者。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://forum.learncocoa.org/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://forum.learncocoa.org/">http://forum.learncocoa.org/</a></span></a></span></span></strong></p>

<p>Cocoa Cafe：这是法国的一个论坛(主要是法语)<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://www.cocoacafe.fr" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.cocoacafe.fr">http://www.cocoacafe.fr</a></span></a></span></span></strong></p>

<p>Apple Developer Forums：这是苹果官方的开发者社区，主要讨论 iOS 和Mac软件开发。许多 iOS 开发初学者和有经验的人(包括苹果的工程师和步道师)，都经常为这个论坛做着贡献。在这里是预发布版的SDK(在NDA限制下)是唯一可以合法讨论的地方。要访问该论坛，需要注册一个Apple ID。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://devforums.apple.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://devforums.apple.com/">http://devforums.apple.com/</a></span></a></span></span></strong></p>

<p>Apple Discussions，Developer Forums：这是苹果的社区论坛(针对Mac和iOS软件开发者)：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://discussions.apple.com/community/developer_forums?categoryID=164" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="https://discussions.apple.com/community/developer_forums?categoryID=164">https://discussions.apple.com/community/developer_forums?categoryID=164</a></span></a></span></span></strong></p>

<p>Apple Discussions，iPhone：这是讨论iPhone的苹果社区论坛<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://discussions.apple.com/community/iphone?categoryID=201" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="https://discussions.apple.com/community/iphone?categoryID=201%C2%A0">https://discussions.apple.com/community/iphone?categoryID=201%C2%A0</a></span></a></span></span></strong></p>

<p>&nbsp;</p>

<p><strong><span style="color: #ff0000;">中文</span></strong></p>

<p>CocoaChina：CocoaChina创立于2008年3月，是一个苹果产品和 iOS 开发的中文社区网站，主要为苹果产品开发者提供资讯、信息及服务。<br/>
<span style="text-decoration: underline; color: #339966;"><strong><span style="text-decoration: underline;"><a href="http://www.cocoachina.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.cocoachina.com/">http://www.cocoachina.com/</a></span></a> </span></strong></span></p>

<p>DevDiv：国内早期比较流行的一个移动开发者社区之一，涉猎 iOS、Android和Windows Phone等各移动平台开发。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.devdiv.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.devdiv.com/">http://www.devdiv.com/</a></span></a></span></span></strong></p>

<p>泰然网：成立于2011年9月，由泰然翻译团队，泰然技术团队，泰然管理团队组成。翻译了大量国外优秀文章，同时也有许多经典原创。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.ityran.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.ityran.com/">http://www.ityran.com/</a></span></a></span></span></strong></p>

<p>Cocos2d-x：Cocos2d-x 是一个开源的支持多平台的 2D 手机游戏引擎。国内难得的一个优秀开源项目。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.cocos2d-x.org/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.cocos2d-x.org/">http://www.cocos2d-x.org/</a></span></a></span></span></strong></p>

<p>&nbsp;</p>

<h2><strong><span style="color: #339966;">4、网站</span></strong></h2>

<p><span style="color: #ff0000;"><b>英文</b></span></p>

<p>github：当下最牛叉的开源代码库和版本控制系统。<br/>
<span style="color: #339966;"><strong><span style="text-decoration: underline;"><span style="text-decoration: underline;"><a href="https://github.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="https://github.com/">https://github.com/</a></span></a></span></span></strong></span></p>

<p>Stack Overflow：这是针对程序员的社区问答网站。许多有经验的iOS程序员会常驻这里回答问题：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://stackoverflow.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://stackoverflow.com/">http://stackoverflow.com/</a></span></a></span></span></strong></p>

<p>除了访问Stack Overflow主站以外，还可以使用标签来浏览iOS开发的相关主题：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://stackoverflow.com/questions/tagged/objective-c" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://stackoverflow.com/questions/tagged/objective-c">http://stackoverflow.com/questions/tagged/objective-c</a></span></a></span></span></strong><br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://stackoverflow.com/questions/tagged/iphone" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://stackoverflow.com/questions/tagged/iphone">http://stackoverflow.com/questions/tagged/iphone</a></span></a></span></span></strong><br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://stackoverflow.com/questions/tagged/xcode" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://stackoverflow.com/questions/tagged/xcode">http://stackoverflow.com/questions/tagged/xcode</a></span></a></span></span></strong><br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://stackoverflow.com/questions/tagged/ios" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://stackoverflow.com/questions/tagged/ios">http://stackoverflow.com/questions/tagged/ios</a></span></a></span></span></strong></p>

<p>maniacdev：该站点是由软件开发者Johann Dowa维护。内容主要包括：iOS 程序开发库、控件、教程、示例和工具。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://maniacdev.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://maniacdev.com/">http://maniacdev.com/</a></span></a></span></span></strong></p>

<p>Cocoa Controls：在这个站点可以找到许多免费并开源的GUI组件(包括iOS和Mac OS)。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://cocoacontrols.com" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://cocoacontrols.com">http://cocoacontrols.com</a></span></a></span></span></strong></p>

<p>NSHipster： 这个站点介绍Objective-C和Cocoa的相关内容。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://nshipster.com" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://nshipster.com">http://nshipster.com</a></span></a></span></span></strong></p>

<p>iOS Fonts：详细列出了iOS中可用的字体。可以选择不同 iOS 版本支持的字体。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://iosfonts.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://iosfonts.com/">http://iosfonts.com/</a></span></a></span></span></strong></p>

<p>Cocoa Dev Central：从2001年以来，该站点就是Mac OS X编程中最流行的站点之一。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://cocoadevcentral.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://cocoadevcentral.com/">http://cocoadevcentral.com/</a></span></a></span></span></strong></p>

<p>cocoanetics： 网站负责人号称天生就是写Objective-C的，里面的文章更新频率也比较快，好多内容(例如Core data)的介绍都比较深入，值得关注。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.cocoanetics.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.cocoanetics.com/">http://www.cocoanetics.com/</a></span></a></span></span></strong></p>

<p>&nbsp;</p>

<p><strong><span style="color: #ff0000;">中文</span></strong></p>

<p>iOS Feed：该站点由许小帅负责维护，许小帅目前任职于腾讯。iOS Feed汇集了许多优秀的iOS开发文章，经常会有新的更新。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://iosfeed.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://iosfeed.com/">http://iosfeed.com/</a></span></a></span></span></strong></p>

<p>Code4App：code4app是一个移动平台的代码库，目前收集了iOS平台几百个代码，并且配有效果图和演示视频。<br/>
<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://code4app.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://code4app.com/">http://code4app.com/</a></span></a></strong></span></span></p>

<p>UI4APP：收集了许多iOS应用的截图，并进行分类浏览，方便美工设计找素材、找灵感。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://ui4app.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://ui4app.com/">http://ui4app.com/</a></span></a></span></span></strong></p>

<p>苹果核：该站点由多人一起维护，其中一名是来自天猫的高嘉峻。苹果核主要探讨开发ios开发，介绍mac os应用，谈论apple产品发展，关注apple相关的一切。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://pingguohe.net/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://pingguohe.net/">http://pingguohe.net/</a></span></a></span></span></strong></p>

<p>&nbsp;</p>

<h2><strong><span style="color: #339966;">5、博客</span></strong></h2>

<p><strong><span style="color: #ff0000;">英文</span></strong></p>

<p>Matt Gemmell的博客：Matt对Objective-C 开发拥有丰富的经验和观点，这些观点非常值得我们去关注<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.mattgemmell.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.mattgemmell.com/">http://www.mattgemmell.com/</a></span></a></span></span></strong></p>

<p>Cocoa is my Girlfriend：这是有Marcus Zarra带领的一批博客，主要集中在iOS和Cocoa开发的问题上。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://cimgf.com" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://cimgf.com">http://cimgf.com</a></span></a></span></span></strong></p>

<p>Ray Wenderlich的博客：实际上Ray站点发展到现在，已经非常的庞大，感觉有点不想博客了，不过还是将其列在博客范围内。对于iOS开发者这个站点提供了非常好的资源，涉及的主题也非常广泛。虽然许多内容是针对游戏开发者的，但是在这个站你总能发现感兴趣的东西。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.raywenderlich.com" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.raywenderlich.com">http://www.raywenderlich.com</a></span></a></span></span></strong></p>

<p>Wolf Rentzsch的博客：Wolf是一个有丰富经验的Cocoa独立开发者，也是C4独立开发者大会(现在已经解散)的创始人。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://rentzsch.tumblr.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://rentzsch.tumblr.com/">http://rentzsch.tumblr.com/</a></span></a></span></span></strong></p>

<p>iDevblogaDay：这是一个有多个作者贡献的博客，阅读这里的内容，会从不同的开发者者身上发现新的见解。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://idevblogaday.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://idevblogaday.com/">http://idevblogaday.com/</a></span></a></span></span></strong></p>

<p>Wil Shipley的博客：在这个星球上，Wil是一个拥有丰富Objective-C开发经验的程序员。他博客中的<strong><em><span style="color: #339966;">Pimp My Code</span></em></strong>系列文章是每一个Objective-C程序都应该阅读的。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://blog.wilshipley.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://blog.wilshipley.com/">http://blog.wilshipley.com/</a></span></a></span></span></strong></p>

<p>Jeff lamarche的博客：Jeff是MartianCraft的创始人，也是Beginning iOS Development系列书籍的作者之一。Jeff是一个非常博学的开发者。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://iphonedevelopment.blogspot.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://iphonedevelopment.blogspot.com/">http://iphonedevelopment.blogspot.com/</a></span></a></span></span></strong></p>

<p>Mike Ash的博客：博客中Mike收集了一些iOS相关的Q&amp;A。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.mikeash.com/pyblog/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.mikeash.com/pyblog/">http://www.mikeash.com/pyblog/</a></span></a></span></span></strong></p>

<p>Joe Conway的博客：Jeo在Big Nerd Ranch带了很长时间，他的博客里面有许多有用的iOS/Cocoa代码和提示。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://stablekernel.com/blog/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://stablekernel.com/blog/">http://stablekernel.com/blog/</a></span></a></span></span></strong></p>

<p>objc.io：深度介绍iOS开发中的最佳实践经验和高级技术。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.objc.io/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.objc.io/">http://www.objc.io/</a></span></a></span></span></strong></p>

<p>iOS Developer Tips：2008年John Muchow就开始写这个博客了。这是第一批关于iPhone开发的博客。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://iosdevelopertips.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://iosdevelopertips.com/">http://iosdevelopertips.com/</a></span></a></span></span></strong></p>

<p>Gregory Hill的博客：里面有许多关于本地化处理的文章。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://blog.appliedis.com/author/gregory-hill/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://blog.appliedis.com/author/gregory-hill/">http://blog.appliedis.com/author/gregory-hill/</a></span></a></span></span></strong></p>

<p>iOS Dev Weekly：这是一些简讯集合的博客，由Dave Verwer负责，订阅之后，每周都会有更新，非常棒。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://iosdevweekly.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://iosdevweekly.com/">http://iosdevweekly.com/</a></span></a></span></span></strong></p>

<p>&nbsp;</p>

<p><strong><span style="color: #ff0000;">中文</span></strong></p>

<p>王巍的博客：王巍目前在日本横滨任职于有趣法人。工作内容主要进行Unity3D开发，8小时之外经常进行iOS/Mac开发。他的陈列柜中已有多款应用，其中番茄工作法工具非常棒。<br/>
<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://onevcat.com" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://onevcat.com">http://onevcat.com</a></span></a></strong></span></span></p>

<p>池建强的博客： 池建强，70后程序员，Blogger。98年毕业，先后就职于洪恩软件、RocketSofeware和用友软件工程公司（后更名为瑞友科技），现任瑞友科技IT应用研究院副院长。该博客最初每天发送一条Mac技巧，不过目前已经形成了一种技术和人文结合的风格，时而随笔，时而技术。<br/>
<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://macshuo.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://macshuo.com/">http://macshuo.com/</a></span></a></strong></span></span></p>

<p>唐巧的博客： 唐巧是前网易有道员工，现在在粉笔网创业中，负责iOS端的开发。博客中的每篇文章都堪称精华，近期分析了支付宝客户端的插件机制，值得细细品读。<br/>
<span style="color: #339966;"><strong><span style="text-decoration: underline;"><a href="http://blog.devtang.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://blog.devtang.com/">http://blog.devtang.com/</a></span></a></span></strong></span></p>

<p>许小帅的博客：许小帅目前任职于腾讯，他还是iOS Feed站点的负责人。博客中对支付宝钱包插件分析的文章，引起了支付宝开发团队的反思，大家可以去感受一下。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://imallen.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://imallen.com/">http://imallen.com/</a></span></a></span></span></strong></p>

<p>蓝晨钰的博客：晨钰目前就读于中山大学。是一名90后iOS开发者。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://gracelancy.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://gracelancy.com/">http://gracelancy.com/</a></span></a></span></span></strong></p>

<p>萧宸宇的博客：萧宸宇目前任职于Sumi Interactive。他出生于西南一个边陲小镇，梦想着能走出家乡，看看祖国的大好河山。他拥有丰富的 iOS 开发经验，在他的博客中发表了许多 iOS 开发的文章。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://iiiyu.com/ " target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://iiiyu.com/%C2%A0">http://iiiyu.com/%C2%A0</a></span></a></span></span></strong></p>

<p>陶丰平的博客：陶丰平目前任职于花瓣网，喜欢技术，喜欢音乐。他在软件开发领域有丰富的开发经验。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.taofengping.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.taofengping.com/">http://www.taofengping.com/</a></span></a></span></span></strong></p>

<p>乔学士的博客：乔学士目前任职于创业公司拓词，他正在为成为“代码手工艺人”而努力，目前主要进行 iOS 开发。最近他做得非常精彩的一件事就是汇总了WWDC 2013 视频英文字幕下载，大家可以前往他的博客感受一下。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://joeyio.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://joeyio.com/">http://joeyio.com/</a></span></a></span></span></strong></p>

<p>破船的博客：破船在移动领域摸爬滚打多年，经历了Symbian、Windows Mobile、Windows Phone和 iOS 等的洗礼。他希望能充分利用业余时间，努力做一名伪步道师。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://beyondvincent.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/">http://beyondvincent.com/</a></span></a></span></span></strong></p>

<p>陈咏聪的博客：陈咏聪现任职于百度，从事 iOS 相关开发。他热爱Web事业，关注设计、产品、开发。沉迷代码，无法自拔。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://vinqon.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://vinqon.com/">http://vinqon.com/</a></span></a></span></span></strong></p>

<p>骆仕恺的博客：骆仕恺目前任职于爱折客 / 爱美味。他主要从事 iOS 和Java开发。拥有丰富的 iOS 开发经验。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://luosky.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://luosky.com/">http://luosky.com/</a></span></a></span></span></strong></p>

<p>耿健桓的博客：耿健桓目前在清华大学攻读硕士，之前他是著名站点知乎的 iOS 技术主管。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://dlog.dismory.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://dlog.dismory.com/">http://dlog.dismory.com/</a></span></a></span></span></strong></p>

<p>李择一的博客：李择一目前任职于百度，他在移动开发领域积累了丰富的经验，特别是 iOS 开发。最近他在博客中发表关于OC中block的追究非常有深度，大家一定要去感受一下。<br/>
<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://cnblogs.com/biosli" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://cnblogs.com/biosli">http://cnblogs.com/biosli</a></span></a></span></strong></span></p>

<p>王轲的博客：王轲是一名 iOS 独立开发者，也是IndieBros Studio创始人。在博客中有几篇关于 iOS 性能优化的文章，值得大家去看看。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.iwangke.me/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.iwangke.me/">http://www.iwangke.me/</a></span></a></span></span></strong></p>

<p>杨宇建的博客： 杨宇建目前任职于载信软件。在他的博客中有许多 iOS 开发的文章，都是干货。<br/>
<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://www.cnblogs.com/easonoutlook/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.cnblogs.com/easonoutlook/">http://www.cnblogs.com/easonoutlook/</a></span></a></span></strong></span></p>

<p>连栩的博客： 连栩目前工作在加拿大温哥华，运营着自己的公司 Beyondcow，他是一名 OSX、iOS 程序员同时也是用户体验，交互界面设计师。在开发的软件 Miao 是一款全功能 Mac 微博客户端。他的博客中有许多Cocoa开发的文章，值得大家去品读。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://lianxu.me/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://lianxu.me/">http://lianxu.me/</a></span></a></span></span></strong></p>

<p>高嘉峻的博客：高嘉峻目前任职于天猫。是一名资深80后，号称会写代码的猪。最近他的博客中出现了两篇关于iOS中单元测试的文章，非常棒。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://jiajun.org/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://jiajun.org/">http://jiajun.org/</a></span></a></span></span></strong></p>

<p>webfrogs的博客：目前在北京当一枚程序猿，有幸成为80后的尾巴。目前行走在iOS开发的道路上，用博客记载一路上的所见所闻所想。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://webfrogs.me/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://webfrogs.me/">http://webfrogs.me/</a></span></a></span></span></strong></p>

<p>&nbsp;</p>

<h2><strong><span style="color: #339966;">6、大会</span></strong></h2>

<p>WWDC：苹果开发者大会是一年一度的盛会，苹果通常会在这里发布新的东西，并且会提供许多开发资源，值得关注。<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="https://developer.apple.com/wwdc/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="https://developer.apple.com/wwdc/">https://developer.apple.com/wwdc/</a></span></a></span></span></strong></p>

<p>&nbsp;</p>

<h2><strong><span style="color: #339966;">7、播客和录像</span><span style="color: #339966;"><br /> </span></strong></h2>

<p>Core intuition：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.coreint.org/podcast.xml" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.coreint.org/podcast.xml">http://www.coreint.org/podcast.xml</a></span></a></span></span></strong></p>

<p>调试<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://feeds.feedburner.com/debugshow" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://feeds.feedburner.com/debugshow">http://feeds.feedburner.com/debugshow</a></span></a></span></span></strong></p>

<p>Edge Cases<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.edgecasesshow.com/rss.xml" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://www.edgecasesshow.com/rss.xml">http://www.edgecasesshow.com/rss.xml</a></span></a></span></span></strong></p>

<p>发展前景<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://developingperspective.com/feed/podcast/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://developingperspective.com/feed/podcast/">http://developingperspective.com/feed/podcast/</a></span></a></span></span></strong></p>

<p>iDeveloper博客：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://feeds.feedburner.com/IdeveloperLive" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://feeds.feedburner.com/IdeveloperLive">http://feeds.feedburner.com/IdeveloperLive</a></span></a></span></span></strong></p>

<p>Software Indie：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://softwareindie.com/feed/podcast" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://softwareindie.com/feed/podcast">http://softwareindie.com/feed/podcast</a></span></a></span></span></strong></p>

<p>NSScreenCast：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://nsscreencast.com/" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://nsscreencast.com/">http://nsscreencast.com/</a></span></a></span></span></strong></p>

<p>&nbsp;</p>

<h2><strong><span style="color: #339966;">参考</span></strong></h2>

<p><strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.davemark.com/?p=1829" target="_blank"><span style="color: #339966; text-decoration: underline;">Resources for Mac and iOS Developers</span></a></span></span></strong></p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-18</time></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC中并发编程的相关API和面临的挑战(2)]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/17/105/"/>
    <updated>2013-07-17T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/17/105</id>
    <content type="html"><![CDATA[<p>本文由<span style="text-decoration: underline;"><a href="http://beyondvincent.com/" target="_blank"><strong><span style="color: #339966; text-decoration: underline;">破船</span></strong></a></span>译自<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html" target="_blank"><span style="color: #339966; text-decoration: underline;">objc</span></a></span></strong></span>转载请注明出处！</p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p><strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/?p=1638" target="_blank"><span style="color: #339966; text-decoration: underline;">上一篇文章</span></a></span></span></strong>介绍了OC中并发编程的相关API，本文我们接着来看看并发编程中面临的一些挑战。</p>

<!--more-->


<h2><strong><span style="color: #339966;">目录</span></strong></h2>

<p><span style="color: #339966;"><b>1、介绍</b></span><br/>
<strong><span style="color: #339966;">2、OS X和iOS中的并发编程</span></strong><br/>
<strong><span style="color: #339966;">    2.1、Threads</span></strong><br/>
<strong><span style="color: #339966;">    2.2、Grand Central Dispatch</span></strong><br/>
<strong><span style="color: #339966;">    2.3、Operation Queues</span></strong><br/>
<strong><span style="color: #339966;">    2.4、Run Loops</span></strong><br/>
<strong><span style="color: #339966;"> 3、并发编程中面临的挑战</span></strong><br/>
<strong><span style="color: #339966;">    3.1、资源共享</span></strong><br/>
<strong><span style="color: #339966;">    3.2、互斥</span></strong><br/>
<strong><span style="color: #339966;">    3.3、死锁</span></strong><br/>
<strong><span style="color: #339966;">    3.4、饥饿</span></strong><br/>
<strong><span style="color: #339966;">    3.5、优先级反转</span></strong><br/>
<strong><span style="color: #339966;"> 4、小结</span></strong></p>

<h3><strong><span style="color: #339966;">正文</span></strong></h3>

<h2><strong><span style="color: #339966;">1和</span></strong><strong><span style="color: #339966;">2两部分内容请看</span></strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/?p=1638" target="_blank"><span style="color: #339966; text-decoration: underline;">上一篇文章</span></a></span></span>。****</h2>

<h2><span style="color: #339966;"><strong>3、并发编程中面临的挑战</strong></span></h2>

<p>使用并发编程会带来许多陷进。尽管开发者做得足够到位了，还是难以观察并行执行中相互作用的多任务的不同状态。问题往往发生在一些不确定性（不可预见性）的地方，在调试相关并发代码时会感觉到很无助。</p>

<p>关于并发编程的不可预见性有一个非常典型的例子：在1995年，NASA(美国宇航局)发送了火星探测器，但是当探测器成功着陆的时候，任务嘎然而止，火星探测器莫名其妙的不停重启——在计算机领域内，遇到的这中现象被定为为优先级反转，也就是说低优先级的线程一直阻塞着高优先级的线程。稍后我们会看到更多相关介绍。通过该示例，可以告诉我们即使拥有丰富的资源和大量优秀工程师，但是也会遭遇使用并发编程带来的陷阱。</p>

<h3><span style="color: #339966;">3.1、资源共享</span></h3>

<p>并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性、一个对象，通用的内存、网络设备和文件等等。在多线程中任意共享的资源都有一个潜在的冲突，开发者必须防止相关冲突的发生。</p>

<p>为了演示冲突问题，我们来看一个关于资源的简单示例：利用一个整型值作为计数器。在程序运行过程中，有两个并行线程A和B，这两个线程都尝试着同时增加计数器的值。问题来了，通过C或OC写的代码(增加计数器的值)不仅仅是一条指令，而是包括好多指令——要想增加计数器的值，需要从内存中读取出当前值，然后再增加计数器的值，最后还需要就爱那个这个增加的值写回内存中。</p>

<p>我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生什么问题。例如，线程A和B都从内存中读取出了计数器的值，假设为17，然后线程A将计数器的值加1，并将结果18写回到内存中。同时，线程B也将计数器的值加1，并将结果18写回到内存中。实际上，此时计数器的值已经被破坏掉了——因为计数器的值17被加1了两次，应该为19，但是内存中的值为18。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/race-condition@2x.png"><img class="alignnone size-full wp-image-1651" alt="race-condition@2x" src="http://beyondvincent.com/wp-content/uploads/2013/07/race-condition@2x.png" width="1148" height="638" /></a></p>

<p>&nbsp;</p>

<p>这个问题成为资源竞争，或者叫做<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://en.wikipedia.org/wiki/Race_conditions#Software" target="_blank"><span style="color: #339966; text-decoration: underline;">race condition</span></a></span></span></strong>，在多线程里面访问一个共享的资源，如果没有一种机制来确保线程A结束访问一个共享资源之前，线程B就开始访问该共享资源，那么资源竞争的问题总是会发生。试想一下，如果如果程序在内存中访问的资源不是一个简单的整型，而是一个复杂的数据结构，可能会发生这样的现象：当第一个线程正在读写这个数据结构时，第二个线程也来读这个数据结构，那么获取到的数据可能是新旧参半。为了防止出现这样的问题，在多线程访问共享资源时，需要一种互斥的机制。</p>

<p>在实际的开发中，情况甚至要比上面介绍的复杂，因为现代CPU为了对代码运行达到最优化，对改变从内存中读写数据的顺序（乱序执行）。</p>

<h3><span style="color: #339966;"> 3.2、互斥</span></h3>

<p><span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://en.wikipedia.org/wiki/Mutex" target="_blank"><span style="color: #339966; text-decoration: underline;">互斥</span></a></span></strong></span>访问的意思就是同一时刻，只允许一个线程访问某个资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://en.wikipedia.org/wiki/Lock_%28computer_science%29" target="_blank"><span style="color: #339966; text-decoration: underline;">互斥锁</span></a></span></span></strong>，一旦某个线程对资源完成了读写操作，就释放掉这个互斥锁，这样别的线程就有机会访问该共享资源了。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/locking@2x.png"><img class="alignnone size-full wp-image-1652" alt="locking@2x" src="http://beyondvincent.com/wp-content/uploads/2013/07/locking@2x.png" width="1248" height="766" /></a></p>

<p>除了确保互斥锁的访问，还需要解决代码无序执行所带来的问题。如果不能确保CPU访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥锁的访问是不够的。为了解决由CPU的优化策略引起的代码无序执行，需要引入内存屏障(<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://en.wikipedia.org/wiki/Memory_barrier" target="_blank"><span style="color: #339966; text-decoration: underline;">memory barrier</span></a></span></span></strong>)。通过设置内存屏障，来确保无序执行时能够正确跨越设置的屏障。</p>

<p>当然，互斥锁的实现是需要自由的竞争条件。这实际上是非常重要的一个保证，并且需要在现代CPU上使用特殊的指令。更多关于原子操作(atomic operation)，请阅读Daniel写的文章：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.objc.io/issue-2/low-level-concurrency-apis.html" target="_blank"><span style="color: #339966; text-decoration: underline;">底层并发技术</span></a></span></span></strong>。</p>

<p>从语言层面来说，在Objective-C中将属性以atomic的形式来声明，就能支持互斥锁了。实际上，默认情况下，属性是atomic的。将一个属性声明为atomic表示每次访问该属性都会进行加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为atomic，但是这也会付出一定的代价。</p>

<p>获取资源上的锁会引发一定的性能代价。获取和释放锁需要自由的竞争条件(race-condition free)，这在多核系统中是很重要的。另外，在获取锁的时候，线程有时候需要等待——因为其它的线程已经获得了资源的锁。这种情况下，线程会进入休眠状态，当其它线程释放掉相关资源的锁时，休眠的线程会得到通知。其实所有这些相关操作都是非常昂贵且复杂的。</p>

<p>这有一些不同类型的锁。当没有竞争时，有些锁是很廉价的(cheap)，但是在竞争情况下，性能就会打折扣。同等条件下，另外一些锁则比较昂贵(expensive)，但是在竞争情况下，会表现更好(锁的竞争是这样产生的：当一个或者多个线程尝试获取一个已经被别的线程获取了的锁)。</p>

<p>在这里有一个东西需要进行权衡：获取和释放锁所带来的开销。开发者需要确保代码中有获取锁和释放锁的语句。同时，如果获取锁之后，要执行一大段代码，这将带来风险：其它线程可能因为资源的竞争而无法工作（需要释放掉相关的锁才行）。</p>

<p>我们经常能看到并行运行的代码，但实际上由于共享资源中配置了相关的锁，所以有时候只有一个线程是出于激活状态的。要想预测一下代码在多核上的调度情况，有时候也显得很重要。我们可以使用Instrument的CPU strategy view来检查是否有效的利用了CPU的可用核数，进而得出更好的想法，以此来优化代码。</p>

<h3><span style="color: #339966;"> 3.3、死锁</span></h3>

<p>互斥解决了资源竞争的问题，但同时这也引入了一个新的问题：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://en.wikipedia.org/wiki/Deadlock" target="_blank"><span style="color: #339966; text-decoration: underline;">死锁</span></a></span></span></strong>。当多个线程在相互等待着对方的结束时，就会发生死锁，这是程序可能会被卡住。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/dead-lock@2x.png"><img class="alignnone size-full wp-image-1653" alt="dead-lock@2x" src="http://beyondvincent.com/wp-content/uploads/2013/07/dead-lock@2x.png" width="906" height="717" /></a></p>

<p>看看下面的代码——交换两个变量的值：</p>

<pre class="wp-code-highlight prettyprint linenums:1">void swap(A, B)
{
    lock(lockA);
    lock(lockB);
    int a = A;
    int b = B;
    A = b;
    B = a;
    unlock(lockB);
    unlock(lockA);
}</pre>


<p>大多数时候，这能够正常运行。但是当两个线程同时调用上面这个方法呢——使用两个相反的值：</p>

<pre class="wp-code-highlight prettyprint linenums:1">swap(X, Y); // thread 1
swap(Y, X); // thread 2</pre>


<p>此时程序可能会由于死锁而被终止。线程1获得了X的一个锁，线程2获得了Y的一个锁。 接着它们会同时等待另外一把锁，但是永远都不会获得。</p>

<p>记住：在线程之间共享更多的资源，会使用更多的锁，同时也会增加死锁的概率。这也是为什么我们需要尽量减少线程间资源共享，并确保共享的资源尽量简单的原因之一。建议阅读以下<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.objc.io/issue-2/low-level-concurrency-apis.html" target="_blank"><span style="color: #339966; text-decoration: underline;">底层并发编程API</span></a></span></span></strong>中的<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.objc.io/issue-2/low-level-concurrency-apis.html#async" target="_blank"><span style="color: #339966; text-decoration: underline;">doing things asynchronously</span></a></span></span></strong>。</p>

<p>&nbsp;</p>

<h3><span style="color: #339966;">3.4、饥饿</span></h3>

<p>当你认为已经足够了解并发编程面临的陷阱 时，拐角处又出现了新的问题。锁定的共享资源会引起读写问题。大多数情况下，限制资源一次只能有一个线程进行访问，这是非常浪费的，比如一个读取锁只允许读，而不对资源进行写操作，这种情况下，同时可能会有另外一个线程等着着获取一个写锁。</p>

<p>为了解决这个问题，更好的方法不是简单使用读/写锁，例如给定一个<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock" target="_blank"><span style="color: #339966; text-decoration: underline;">writer preference</span></a></span></span></strong>，或者使用<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://en.wikipedia.org/wiki/Read-copy-update" target="_blank"><span style="color: #339966; text-decoration: underline;">read-copy-update</span></a></span></span></strong>算法。Daniel在<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.objc.io/issue-2/low-level-concurrency-apis.html#multiple-readers-single-writer" target="_blank"><span style="color: #339966; text-decoration: underline;">底层并发技术文章</span></a></span></span></strong>中有相关介绍。</p>

<h3><span style="color: #339966;"> 3.5、优先级反转</span></h3>

<p>本节开头介绍了美国宇航局发射的火星探测器在火星上遇到的并发问题。现在我们就来看看为什么那个火星探测器会失败，以及为什么有时候我们的程序也会遇到相同的问题——该死的优先级反转。</p>

<p>优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。由于GCD提供了后台运行队列(拥有不同的优先级)，包括I/O队列，所以通过GCD我们可以很好的来了解一下优先级反转的可能性。</p>

<p>高优先级和低优先级的任务之间在共享一个资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，然后让高优先级的任务在没有明显的延时下继续执行。然而当低优先级阻塞着高优先级期间(低优先级获得的时间又比较少)，如果有一个中优先级的任务(该任务不需要那个共享资源)，那么可能会抢占低优先级任务，而被执行——因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，也就会引起高优先级任务一直在等待锁的释放。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/priority-inversion@2x.png"><img class="alignnone size-full wp-image-1654" alt="priority-inversion@2x" src="http://beyondvincent.com/wp-content/uploads/2013/07/priority-inversion@2x.png" width="1018" height="700" /></a></p>

<p>在我们的实际代码中，可能不会像火星探测器那样，遇到优先级反转时，不同的重启。</p>

<p>解决这个问题的方法，通常就是不要使用不同的优先级——将高优先级的代码和低优先级的代码修改为相同的优先级。当使用GCD时，总是使用默认的优先级队列。如果使用不同的优先级，就可能会引发事故。</p>

<p>虽然有些文章上说，在不同的队列中使用不同的优先级，这听起来不错，但是这回增加并发编程的复杂度和不可预见性。如果编程中，在高优先级任务中突然没有理由的卡住了，可能你会想起本文，以及称为优先级反转的问题，甚至还会想起美国宇航局的工程师也遇到这样的问题。</p>

<h2><span style="color: #339966;">4、小结</span></h2>

<p>希望通过本文你能够了解到并发编程带来的复杂性和相关问题。并发编程中，看起来，无论是多么简单的API，由此产生的问题会变得非常的难以观测，并且要想调试这类问题，往往都是比较困难的。</p>

<p>另外，并发实际上是一个非常棒的功能——它充分利用了现代多核CPU的强大计算能力。在开发中，关键的一点就是尽量让并发模型简单，这样可以限制锁的数量。</p>

<p>我们建议采纳的安全模式是这样的：从主线程中提取出使用到的数据，并利用一个操作队列在后台处理相关的数据，然后将后台处理的结果反馈到主队列中。使用这种方式，开发者不需要自己负责任何的锁，这也就减少了犯错误的概率。</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-17</time></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OC中并发编程的相关API和面临的挑战(1)]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/16/104/"/>
    <updated>2013-07-16T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/16/104</id>
    <content type="html"><![CDATA[<p>本文由<strong><span style="color: #339966;">破船</span></strong>译自<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html" target="_blank"><span style="color: #339966; text-decoration: underline;">objc</span></a></span></strong></span>转载请注明出处！</p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p><a href="http://www.objc.io/">http://www.objc.io/</a> 站点主要以杂志的形式，深入挖掘在OC中的最佳编程实践和高级技术，每个月探讨一个主题，每个主题都会有几篇相关的文章出炉，2013年7月份的主题是并发编程，今天晚上我就挑选其中的第2篇文章(<a href="http://www.objc.io/issue-2/concurrency-apis-and-pitfalls.html"><code>Concurrent Programming: APIs and Challenges</code></a>)进行翻译，与大家分享一下主要内容。由于内容比较多，我将分两部分翻译(API和难点)完成，翻译中，如有错误，还请指正。</p>

<!--more-->


<h2><strong><span style="color: #339966;">目录</span></strong></h2>

<p><span style="color: #339966;"><b>1、介绍</b></span><br/>
<strong><span style="color: #339966;">2、OS X和iOS中的并发编程</span></strong><br/>
<strong><span style="color: #339966;">    2.1、Threads</span></strong><br/>
<strong><span style="color: #339966;">    2.2、Grand Central Dispatch</span></strong><br/>
<strong><span style="color: #339966;">    2.3、Operation Queues</span></strong><br/>
<strong><span style="color: #339966;">    2.4、Run Loops</span></strong><br/>
<strong><span style="color: #339966;"> 3、并发编程中面临的挑战</span></strong><br/>
<strong><span style="color: #339966;">    3.1、资源共享</span></strong><br/>
<strong><span style="color: #339966;">    3.2、互斥</span></strong><br/>
<strong><span style="color: #339966;">    3.3、死锁</span></strong><br/>
<strong><span style="color: #339966;">    3.4、饥饿</span></strong><br/>
<strong><span style="color: #339966;">    3.5、优先级反转</span></strong><br/>
<strong><span style="color: #339966;"> 4、小结</span></strong></p>

<h3><strong><span style="color: #339966;">正文</span></strong></h3>

<h2><strong><span style="color: #339966;">1、介绍</span></strong></h2>

<p><span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"> <a href="http://en.wikipedia.org/wiki/Concurrency_%28computer_science%29"><span style="color: #339966; text-decoration: underline;">并发</span></a></span></strong></span>的意思就是同时运行多个任务，这些任务可以在单核CPU上以<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://en.wikipedia.org/wiki/Preemption_%28computing%29"><span style="color: #339966; text-decoration: underline;">分时(时间共享)</span></a></span></span></strong>的形式同时运行，或者在多核CPU上以真正的并行来运行多任务。</p>

<p>OS X和iOS提供了几种不同的API来支持并发编程。每种API都具有不同的功能和一些限制，一般是根据不同的任务使用不同的API。这些API在系统中处于不同的地方。并发编程对于开发者来说非常的强大，但是作为开发者需要担负很大的责任，来把任务处理好。</p>

<p>实际上，并发编程是一个很有挑战的主题，它有许多错综复杂的问题和陷阱，当开发者在使用类似<strong><span style="color: #339966;">GCD</span></strong>或<strong><span style="color: #339966;">NSOperationQueue</span></strong> API时，很容易遗忘这些问题和陷阱。本文首先介绍一下OS X和iOS中不同的并发编程API，然后深入了解并发编程中开发者需要面临的一些挑战。</p>

<h2><strong><span style="color: #339966;">2、OS X和iOS中的并发编程</span></strong></h2>

<p>在移动和桌面操作系统中，苹果提供了相同的并发编程API。 本文会介绍<strong><span style="color: #339966;">pthread</span></strong>和<strong><span style="color: #339966;">NSThread</span></strong>、<strong><span style="color: #339966;">Grand Central Dispatch(GCD)</span></strong>、<strong><span style="color: #339966;">NSOperationQueue</span></strong>，以及<strong><span style="color: #339966;">NSRunLoop</span></strong>。NSRunLoop列在其中，有点奇怪，因为它并没有被用来实现真正的并发，不过NSRunLoop与并发编程有莫大的关系，值得我们去了解。</p>

<p>由于高层API是基于底层API构建的，所以首先将从底层的API开始介绍，然后逐步介绍高层API，不过在具体编程中，选择API的顺序刚好相反：因为大多数情况下，选择高层的API不仅可以完成底层API能完成的任务，而且能够让并发模型变得简单。</p>

<p>如果你对这里给出的建议(API的选择)上有所顾虑，那么你可以看看本文的相关内容：<strong><span style="color: #339966;">并发编程面临的挑战</span></strong>，以及Peter Steinberger写的关于<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://www.objc.io/issue-2/thread-safe-class-design.html" target="_blank"><span style="color: #339966; text-decoration: underline;">线程安全</span></a></span></span></strong>的文章。</p>

<h3><strong><span style="color: #339966;">2.1、Threads</span></strong></h3>

<p>线程(thread)是组成进程的子单元，操作系统的调度器可以对线程进行单独的调度。实际上，所有的并发编程API都是构建于线程之上的——包括GCD和操作队列(operation queues)。</p>

<p>多线程可以在单核CPU上同时运行(可以理解为同一时间)——操作系统将时间片分配给每一个线程，这样就能够让用户感觉到有多个任务在同时进行。如果CPU是多核的，那么线程就可以真正的以并发方式被执行，所以完成某项操作，需要的总时间更少。</p>

<p>开发者可以通过Instrument中的<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/AnalysingCPUUsageinYourOSXApp/AnalysingCPUUsageinYourOSXApp.html" target="_blank"><span style="color: #339966; text-decoration: underline;">CPU strategy view</span></a></span></span></strong>来观察代码被执行时在多核CPU中的调度情况。</p>

<p>需要重点关注的一件事：开发者无法控制代码在什么地方以及什么时候被调度，以及无法控制代码执行多长时间后将被暂停，以便轮到执行别的任务。线程调度是非常强大的一种技术，但是也非常复杂(稍后会看到)。</p>

<p>先把线程调度的复杂情况放一边，开发者可以使用<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/POSIX_Threads" target="_blank"><span style="color: #339966; text-decoration: underline;">POSIX线程</span></a></span></span></strong>API，或者Objective-C中提供的对该API的封装——<strong><span style="color: #339966;">NSThread</span></strong>，来创建自己的线程。下面这个小示例是利用<strong><span style="color: #339966;">pthread</span></strong>来查找在一百万个数字中的最小值和最大值。其中并发执行了4个线程。从该示例复杂的代码中，可以看出为什么我们不希望直接使用pthread。</p>

<pre class="wp-code-highlight prettyprint linenums:1">struct threadInfo {
    uint32_t * inputValues;
    size_t count;
};

struct threadResult {
    uint32_t min;
    uint32_t max;
};

void * findMinAndMax(void *arg)
{
    struct threadInfo const * const info = (struct threadInfo *) arg;
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i &lt; info&gt;count; ++i) {
        uint32_t v = info&gt;inputValues[i];
        min = MIN(min, v);
        max = MAX(max, v);
    }
    free(arg);
    struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result));
    result&gt;min = min;
    result&gt;max = max;
    return result;
}

int main(int argc, const char * argv[])
{
    size_t const count = 1000000;
    uint32_t inputValues[count];

    // Fill input values with random numbers:
    for (size_t i = 0; i &lt; count; ++i) {
        inputValues[i] = arc4random();
    }

    // Spawn 4 threads to find the minimum and maximum:
    size_t const threadCount = 4;
    pthread_t tid[threadCount];
    for (size_t i = 0; i &lt; threadCount; ++i) {         struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info));         size_t offset = (count / threadCount) * i;         info&gt;inputValues = inputValues + offset;
        info&gt;count = MIN(count - offset, count / threadCount);
        int err = pthread_create(tid + i, NULL, &findMinAndMax, info);
        NSCAssert(err == 0, @"pthread_create() failed: %d", err);
    }
    // Wait for the threads to exit:
    struct threadResult * results[threadCount];
    for (size_t i = 0; i &lt; threadCount; ++i) {
        int err = pthread_join(tid[i], (void **) &(results[i]));
        NSCAssert(err == 0, @"pthread_join() failed: %d", err);
    }
    // Find the min and max:
    uint32_t min = UINT32_MAX;
    uint32_t max = 0;
    for (size_t i = 0; i &lt; threadCount; ++i) {         min = MIN(min, results[i]&gt;min);
        max = MAX(max, results[i]&gt;max);
        free(results[i]);
        results[i] = NULL;
    }

    NSLog(@"min = %u", min);
    NSLog(@"max = %u", max);
    return 0;
}</pre>


<p><strong><span style="color: #339966;">NSThread</span></strong>是Objective-C对<strong><span style="color: #339966;">pthread</span></strong>的一个封装。通过封装，在Cocoa环境中，可以让代码看起来更加亲切。例如，开发者可以利用NSThread的一个子类来定义一个线程，在这个子类的中封装了需要运行的代码。针对上面的那个例子，我们可以定义一个这样的NSThread子类：</p>

<pre class="wp-code-highlight prettyprint linenums:1">@interface FindMinMaxThread : NSThread
@property (nonatomic) NSUInteger min;
@property (nonatomic) NSUInteger max;
- (instancetype)initWithNumbers:(NSArray *)numbers;
@end

@implementation FindMinMaxThread {
    NSArray *_numbers;
}

- (instancetype)initWithNumbers:(NSArray *)numbers 
{
    self = [super init];
    if (self) {
        _numbers = numbers;
    }
    return self;
}

- (void)main
{
    NSUInteger min;
    NSUInteger max;
    // process the data
    self.min = min;
    self.max = max;
}
@end</pre>


<p>要想启动一个新的线程，需要创建一个线程对象，然后调用它的<strong><span style="color: #339966;">start</span></strong>方法：</p>

<pre class="wp-code-highlight prettyprint linenums:1">NSSet *threads = [NSMutableSet set];
NSUInteger numberCount = self.numbers.count;
NSUInteger threadCount = 4;
for (NSUInteger i = 0; i &lt; threadCount; i++) {
    NSUInteger offset = (count / threadCount) * i;
    NSUInteger count = MIN(numberCount - offset, numberCount / threadCount);
    NSRange range = NSMakeRange(offset, count);
    NSArray *subset = [self.numbers subarrayWithRange:range];
    FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];
    [threads addObject:thread];
    [thread start];
}</pre>


<p>现在，当4个线程结束的时候，我们检测到线程的isFinished属性。不过最好还是远离上面的代码吧——最主要的原因是，在编程中，直接使用线程（无论是pthread，还是NSThread）都是难以接受的。</p>

<p>使用线程会引发的一个问题就是：在开发者自己的代码，或者系统内部的框架代码中，被激活的线程数量很有可能会成倍的增加——这对于一个大型工程来说，是很常见的。例如，在8核CPU中，你创建了8个线程，然后在这些线程中调用了框架代码，这些代码也创建了同样的线程(其实它并不知道你已经创建好线程了)，这样会很快产生成千上万个线程，最终导致你的程序被终止执行——线程实际上并不是免费的咖啡，每个线程的创建都会消耗一些内容，以及相关的内核资源。</p>

<p>下面，我将介绍两个基于队列的并发编程API：GCD和operation queue。它们通过集中管理一个线程池(被没一个任务协同使用)，来解决上面遇到的问题。</p>

<p><strong style="font-size: 1.17em;"><span style="color: #339966;">2.2、Grand Central Dispatch</span></strong></p>

<p>为了让开发者更加容易的使用设备上的多核CPU，苹果在OS X和iOS 4中引入了Grand Central Dispatch(GCD)。在下一篇文章中会更加详细的介绍GCD：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.objc.io/issue-2/low-level-concurrency-apis.html" target="_blank"><span style="color: #339966; text-decoration: underline;">low-level concurrency APIs</span></a></span></span></strong>。</p>

<p>通过GCD，开发者不用再直接跟线程打交道了，只需要向队列中添加block代码即可，GCD在后端管理着一个线程池。GCD不仅决定着哪个线程(block)将被执行，它还根据可用的系统资源对线程池中的线程进行管理——这样可以不通过开发者来集中管理线程，缓解大量线程的创建，做到了让开发者远离线程的管理。</p>

<p>默认情况下，GCD公开有5个不同的队列：运行在主线程中的main queue，3个不同优先级的后台队列，以及一个优先级更低的后台队列(用于I/O)。另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有block都将被放入到系统的线程池的一个全局队列中。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/gcd-queues@2x.png"><img class="alignnone size-full wp-image-1639" alt="gcd-queues@2x" src="http://beyondvincent.com/wp-content/uploads/2013/07/gcd-queues@2x.png" width="1256" height="726" /></a></p>

<p>这里队列中，可以使用不同优先级，这听起来可能非常简单，不过，强烈建议，在大多数情况下使用默认的优先级就可以了。在队列中调度具有不同优先级的任务时，如果这些任务需要访问一些共享的资源，可能会迅速引起不可预料到的行为，这样可能会引起程序的突然停止——运行时，低优先级的任务阻塞了高优先级任务。更多相关内容，在本文的<strong><span style="color: #339966;">优先级反转</span></strong>中会有介绍。</p>

<p>虽然GCD是稍微偏底层的一个API，但是使用起来非常的简单。不过这也容易使开发者忘记并发编程中的许多注意事项和陷阱。读者可以阅读本文后面的：并发编程中面临的挑战，这样可以注意到一些潜在的问题。本期的另外一篇文章：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.objc.io/issue-2/low-level-concurrency-apis.html" target="_blank"><span style="color: #339966; text-decoration: underline;">Low-level Concurrency API</span></a></span></span></strong>，给出了更加深入的解释，以及一些有价值的提示。</p>

<h3><strong><span style="color: #339966;"> 2.3、Operation Queues</span></strong></h3>

<p>操作队列(operation queue)是基于GCD封装的一个队列模型。GCD提供了更加底层的控制，而操作队列在GCD之上实现了一些方便的功能，这些功能对于开发者来说会更好、更安全。</p>

<p>类NSOperationQueue有两个不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。任何情况下，在这两种队列中运行的任务，都是由NSOperation组成。</p>

<p>定义自己的操作有两种方式：重写main或者start方法，前一种方法非常简单，但是灵活性不如后一种。对于重写main方法来说，开发者不需要管理一些状态属性(例如isExecuting和isFinished)——当main返回的时候，就可以假定操作结束。</p>

<pre class="wp-code-highlight prettyprint linenums:1">@implementation YourOperation
    - (void)main
    {
        // do your work here ...
    } 
@end</pre>


<p>如果你希望拥有更多的控制权，以及在一个操作中可以执行异步任务，那么就重写start方法：</p>

<pre class="wp-code-highlight prettyprint linenums:1">@implementation YourOperation
    - (void)start
    {
        self.isExecuting = YES;
        self.isFinished = NO;
        // start your work, which calls finished once it&#039;s done ...
    }

    - (void)finished
    {
        self.isExecuting = NO;
        self.isFinished = YES;
    }
@end</pre>


<p>注意：这种情况下，需要开发者手动管理操作的状态。 为了让操作队列能够捕获到操作的改变，需要将状态属性以KVO的方式实现。并确保状态改变的时候发送了KVO消息。</p>

<p>为了满足操作队列提供的取消功能，还应该检查isCancelled属性，以判断是否继续运行。</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)main
{
    while (notDone && !self.isCancelled) {
        // do your processing
    }
}</pre>


<p>当开发者定义好操作类之后，就可以很容易的将一个操作添加到队列中：</p>

<pre class="wp-code-highlight prettyprint linenums:1">NSOperationQueue *queue = [[NSOperationQueue alloc] init];
YourOperation *operation = [[YourOperation alloc] init];
[queue  addOperation:operation];</pre>


<p>另外，开发者也可以将block添加到队列中。这非常的方便，例如，你希望在主队列中调度一个一次性任务：</p>

<pre class="wp-code-highlight prettyprint linenums:1">[[NSOperationQueue mainQueue] addOperationWithBlock:^{
    // do something...
}];</pre>


<p>如果重写operation的description方法，可以很容易的标示出在某个队列中当前被调度的所有operation。</p>

<p>除了提供基本的调度操作或block外，操作队列还提供了一些正确使用GCD的功能。例如，可以通过maxConcurrentOperationCount属性来控制一个队列中可以有多少个操作参与并发执行，以及将队列设置为一个串行队列。</p>

<p>另外还有一个方便的功能就是根据队列中operation的优先级对其进行排序，这不同于GCD的队列优先级，它只会影响到一个队列中所有被调度的operation的执行顺序。如果你需要进一步控制operation的执行顺序(除了使用5个标准的优先级)，还可以在operation之间指定依赖，如下：</p>

<pre class="wp-code-highlight prettyprint linenums:1">[intermediateOperation addDependency:operation1];
[intermediateOperation addDependency:operation2];
[finishedOperation addDependency:intermediateOperation];</pre>


<p>上面的代码可以确保operation1和operation在intermediateOperation之前执行，也就是说，在finishOperation之前被执行。对于需要明确的执行顺序时，操作依赖是非常强大的一个机制。 它可以让你创建一些操作组，并确保这些操作组在所依赖的操作之前被执行，或者在并发队列中以串行的方式执行operation。</p>

<p>从本质上来看，操作队列的性能比GCD要低，不过，大多数情况下，可以忽略不计，所以操作队列是并发编程的首选API。</p>

<h3><strong><span style="color: #339966;"> 2.4、Run Loops</span></strong></h3>

<p>实际上，Run loop并不是一项并发机制(例如GCD或操作队列)，因为它并不能并行执行任务。不过在主dispatch/operation队列中，run loop直接配合着任务的执行，它提供了让代码异步执行的一种机制。</p>

<p>Run loop比起操作队列或者GCD来说，更加容易使用，因为通过run loop，开发者不必处理并发中的复杂情况，就能异步的执行任务。</p>

<p>一个run loop总是绑定到某个特定的线程中。main run loop是与主线程相关的，在每一个Cocoa和CocoaTouch程序中，这个main run loop起到核心作用——它负责处理UI时间、计时器，以及其它内核相关事件。无论什么时候使用计时器、NSURLConnection或者调用performSelector:withObject:afterDelay:，run loop都将在后台发挥重要作用——异步任务的执行。</p>

<p>无论什么时候，依赖于run loop使用一个方法，都需要记住一点：run loop可以运行在不同的模式中，每种模式都定义了一组事件，供run loop做出响应——这其实是非常聪明的一种做法：在main run loop中临时处理某些任务。</p>

<p>在iOS中非常典型的一个示例就是滚动，在进行滚动时，run loop并不是运行在默认模式中的，因此，run loop此时并不会做出别的响应，例如，滚动之前在调度一个计时器。一旦滚动停止了，run loop会回到默认模式，并执行添加到队列中的相关事件。如果在滚动时，希望计时器能被触发，需要将其在NSRunLoopCommonModes模式下添加到run loop中。</p>

<p>其实，一般情况下都没有必要去配置使用非主线的其他线程的runloop，若有繁重的工作不想卡在主线程还有很多别的方法可以使用。相关内容，Chris写了一篇文章，可以去看看：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.objc.io/issue-2/common-background-practices.html" target="_blank"><span style="color: #339966; text-decoration: underline;">common background practices</span></a></span></span></strong>。</p>

<p>如果你真需要在别的线程中添加一个run loop，那么不要忘记在run loop中至少添加一个input source。如果run loop中没有input source，那么每次运行这个run loop，都会立即退出。</p>

<p>关于并发编程中面临的挑战，会在下一篇文章中出现。</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-16</time></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7新特征汇总[07]Xcode 5中非常期待的6个功能]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/15/103/"/>
    <updated>2013-07-15T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/15/103</id>
    <content type="html"><![CDATA[<p>提醒：这里是新特征汇总博文链接：<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/2013/06/11/ios7%E6%96%B0%E7%89%B9%E5%BE%81%E6%B1%87%E6%80%BB/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总</span></a></strong></span></span></p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-2.jpg"><img class="alignnone size-full wp-image-1595" alt="QQ20130715-2" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-2.jpg" width="1069" height="598" /></a></p>

<p>&nbsp;</p>

<h2><strong><span style="color: #339966;">小引：</span></strong></h2>

<p>自从北京时间2013年06月11日苹果发布Xcode 5 Developer Preview 1，到现在(2013年7约15日)已经过去一个月，苹果也放出了Xcode 5 Developer Preview 3，速度还是蛮快的，希望体验的同学也可以去苹果官网下载。</p>

<p>今晚看了一下WWDC2013的session：<strong><span style="color: #ff0000;">What’s New in Xcode 5</span></strong>。那就来说说Xcode 5里面一些值得期待的东西吧。由于Xcode中的新东西比较多，我这里挑选了6个非常好的新东西，供大家了解，如果需要了解更多内容，请移步到上面说的session中。</p>

<p>另：在看视频过程中，要特别感谢<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://joeyio.com/" target="_blank"><span style="color: #339966; text-decoration: underline;">乔学士先生</span></a></span></span></strong>汇总的<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="https://github.com/qiaoxueshi/WWDC_2013_Video_Subtitle" target="_blank"><span style="color: #339966; text-decoration: underline;">WWDC2013英文字幕</span></a></span></strong></span>。大家可以想象一下，本来英语就不好的拉，要是没有字幕，要想看懂老外讲的内容，那该痛上加痛哈。</p>

<!--more-->


<h2><strong><span style="color: #339966;">目录</span></strong></h2>

<p><strong><span style="color: #339966;">0、介绍</span></strong><br/>
<strong><span style="color: #339966;"> 1、Toolbar减小30%</span></strong><br/>
<strong><span style="color: #339966;"> 2、源码控制</span></strong><br/>
<strong><span style="color: #339966;"> 3、自动配置</span></strong><br/>
<strong><span style="color: #339966;"> 4、代码文档能力</span></strong><br/>
<strong><span style="color: #339966;"> 5、Datatip</span></strong><br/>
<strong><span style="color: #339966;"> 6、Debug 仪表</span></strong><br/>
<strong><span style="color: #339966;">7、破船有话要说</span></strong></p>

<p>&nbsp;</p>

<h3><strong><span style="color: #339966;">正文</span></strong></h3>

<h2><strong><span style="color: #339966;">0、介绍</span></strong></h2>

<p>该session(What&#8217;s New in Xcode 5)介绍了Xcode 5里面为开发者带来的许多新内容，使用过Xcode的同学可能都已经知道，Xcode就是一个完整的开发工具包，可以用来开发在Mac、iPhone和iPad上面的运行的软件。Xcode提供了Instrument 分析工具、iOS模拟器以及操作系统(iOSOS X)相关的一些框架等。</p>

<p>下面就来看看这些值得期待的东西吧。</p>

<h3><strong><span style="color: #339966;">1、Toolbar减小30%</span></strong></h3>

<p>如下图所示，这样做的目的主要就是让Xcode能够尽可能多的显示与编码相关的内容，让开发者专心写代码。从图中也可以看出，Xcode 5与iOS 7的设计理念有相通之处——扁平化。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-1.jpg"><img class="alignnone size-full wp-image-1594" alt="QQ20130715-1" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-1.jpg" width="1213" height="698" /></a></p>

<p>&nbsp;</p>

<p>如下图所示，我们可以看看Toolbar在Xcode 4和Xcode 5中的对比(左边为Xcode 4，右边为Xcode 5)</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-3.jpg"><img class="alignnone size-full wp-image-1596" alt="QQ20130715-3" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-3.jpg" width="729" height="383" /></a></p>

<p>&nbsp;</p>

<h3><strong><span style="color: #339966;">2、源码控制</span></strong></h3>

<p>在Xcode 5中，可以从一个已有的工程中check out代码，然后进行开发。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-5.jpg"><img class="alignnone size-full wp-image-1598" alt="QQ20130715-5" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-5.jpg" width="1123" height="603" /></a></p>

<p>可以方便的浏览和选择Rep。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-6.jpg"><img class="alignnone size-full wp-image-1599" alt="QQ20130715-6" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-6.jpg" width="934" height="558" /></a></p>

<p>&nbsp;</p>

<p>在菜单中，有一个Source Control，可以方便的对代码进行Commit、Push、Pull、选择分支、创建分支等操作。如下图所示：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-7.jpg"><img class="alignnone size-full wp-image-1601" alt="QQ20130715-7" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-7.jpg" width="1220" height="507" /></a></p>

<p>&nbsp;</p>

<p>另外，还可以方便的查找到某行代码是谁修改的，如下图：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-8.jpg"><img class="alignnone size-full wp-image-1602" alt="QQ20130715-8" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-8.jpg" width="687" height="275" /></a></p>

<p>&nbsp;</p>

<h3><strong><span style="color: #339966;">3、自动配置</span></strong></h3>

<p>只需要在Xcode账号中输入Apple ID，Xcode就能够帮助开发者完成一些配置项(iCloud、Game Center、Passbook和Maps等)，作为开发者只需要简单的打开或者关闭相关功能即可，Xcode会自动的发送provisioning profile、创建entitlement、更新Info.plist文件、甚至是链接到所需要的框架——所有这些繁琐的事情都不再需要开发者亲自操作了。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-9.jpg"><img class="alignnone size-full wp-image-1603" alt="QQ20130715-9" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-9.jpg" width="979" height="710" /></a></p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-10.jpg"><img class="alignnone size-full wp-image-1604" alt="QQ20130715-10" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-10.jpg" width="1105" height="553" /></a></p>

<p>&nbsp;</p>

<h3><strong><span style="color: #339966;">4、代码文档能力</span></strong></h3>

<p>从现在开始，Xcode可以从api中提取出文档注释了。相信这是好多开发者都期望有的功能。如下图所示：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-11.jpg"><img class="alignnone size-full wp-image-1605" alt="QQ20130715-11" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-11.jpg" width="1054" height="469" /></a></p>

<p>&nbsp;</p>

<h3><strong><span style="color: #339966;">5、Datatip</span></strong></h3>

<p>在利用Xcode调试代码的时候，通过Datatip可以可以非常方便的查看变量的值。</p>

<p>Datatip可以显示出来自LLDB的概要信息，以及打印出某个变量的描述信息(不用再跑到consle中输入PO啦)，如下图：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-13.jpg"><img class="alignnone size-full wp-image-1607" alt="QQ20130715-13" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-13.jpg" width="1093" height="593" /></a></p>

<p>当然，图文信息也可以方便的显示出来，如下所示：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-14.jpg"><img class="alignnone size-full wp-image-1608" alt="QQ20130715-14" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-14.jpg" width="1018" height="565" /></a></p>

<p>&nbsp;</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-15.jpg"><img class="alignnone size-full wp-image-1609" alt="QQ20130715-15" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-15.jpg" width="1112" height="648" /></a></p>

<p>&nbsp;</p>

<h3><strong><span style="color: #339966;">6、Debug 仪表</span></strong></h3>

<p>通过Debug仪表可以显示出程序运行时，CPU、内存等实际发生的事情，这样可以非常容易的查出并修正潜在的bug。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-16.jpg"><img class="alignnone size-full wp-image-1610" alt="QQ20130715-16" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-16.jpg" width="876" height="657" /></a> <a href="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-17.jpg"><img class="alignnone size-full wp-image-1611" alt="QQ20130715-17" src="http://beyondvincent.com/wp-content/uploads/2013/07/QQ20130715-17.jpg" width="997" height="668" /></a></p>

<p>&nbsp;</p>

<p><strong><span style="color: #339966;">7、破船有话要说</span></strong></p>

<p>还记得使用Xcode 3版本开发iOS程序的时候，感觉这个工具不好使用，当时的IB和Xcode还是分开的，打开个xib文件，IB也要启动半天，更别说界面与代码的整体开发效率了。现如今看到苹果对Xcode做了很多改进，使用越来越方便，开发效率也大大提升，这对大多数开发者来说，绝对是福利！！！</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-15</time></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block剧终：Objective-C中的闭包性和匿名函数]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/12/102/"/>
    <updated>2013-07-12T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/12/102</id>
    <content type="html"><![CDATA[<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/blocks-1024x576.jpg"><img class="alignnone size-full wp-image-1586" alt="blocks-1024x576" src="http://beyondvincent.com/wp-content/uploads/2013/07/blocks-1024x576.jpg" width="1024" height="576" /></a></p>

<p>本文由<strong><span style="color: #339966;">破船</span></strong>译自<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://www.xs-labs.com/en/archives/articles/objc-blocks/" target="_blank"><span style="color: #339966; text-decoration: underline;">xs-labs</span></a></span></span></strong>转载请注明出处！</p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>还记得昨天我给大家推荐的文章吗：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.xs-labs.com/en/archives/articles/objc-blocks/" target="_blank"><span style="color: #339966; text-decoration: underline;">Closure and anonymous functions in Objective-C</span></a></span></strong></span>。今天手痒，还想继续敲几个字，索性我就把这篇文章敲出来，以此对block说声代码里见吧。</p>

<!--more-->


<h2><strong><span style="color: #339966;">目录</span></strong></h2>

<p><strong><span style="color: #339966;">1、关于</span></strong><br/>
<strong><span style="color: #339966;">    1.1匿名函数</span></strong><br/>
<strong><span style="color: #339966;">    1.2闭包性</span></strong></p>

<p><strong><span style="color: #339966;">2、Objective-C中的实现</span></strong><br/>
<strong><span style="color: #339966;">    2.1将block当做参数来传递</span></strong><br/>
<strong><span style="color: #339966;">    2.2闭包性</span></strong><br/>
<strong><span style="color: #339966;">    2.3内存管理</span></strong><br/>
<strong><span style="color: #339966;">    2.4示例</span></strong></p>

<h3><strong><span style="color: #339966;">正文</span></strong></h3>

<h2><strong><span style="color: #339966;">1、关于</span></strong></h2>

<p>许多脚本语言都支持<strong><span style="color: #339966;">lambda表达式</span></strong>和<strong><span style="color: #339966;">匿名函数</span></strong>。这两个概念经常与<strong><span style="color: #339966;">闭包性</span></strong>(<strong><span style="color: #339966;">closure</span></strong>)相关。例如在JavaScript、ActionScript或PHP(5.3之后)中都有相关的概念。</p>

<p>其实在Objective-C语言中也提供了这两个概念的实现：叫做<strong><span style="color: #339966;">block</span></strong>。</p>

<p>自从Mac OS X 10.6之后，就可以使用block了，其实这样归功于Clang。</p>

<h3><strong><span style="color: #339966;">1.1 匿名函数</span></strong></h3>

<p>就如名字暗示的一样，匿名函数实际上就是一个没有名字或者标示(<strong><span style="color: #339966;">identifier</span></strong>)的函数。匿名函数只有内容(也可以叫做body)，我们可以将其存储在一个变量中，以便之后使用，或者将其当做一个参数传递给另外一个函数使用。</p>

<p>在脚本语言的回调中经常使用到这个概念。</p>

<p>例如，在下面的JavaScript中，有一个名为<strong><span style="color: #339966;">foo</span></strong>的标准函数，接收一个callback当做参数，在函数中，调用了这个callback：</p>

<pre class="wp-code-highlight prettyprint linenums:1">function foo( callback )
{
    callback();
}</pre>


<p>这里有可能是定义了另外一个标准函数， 然后将这个标准函数当做参数传递给上面的函数：</p>

<pre class="wp-code-highlight prettyprint linenums:1">function bar()
{
    alert( &#039;hello, world&#039; );
}

foo( bar );</pre>


<p>不过这样一来，<strong><span style="color: #339966;">bar</span></strong>函数就会被声明在全局范围内，这就会带来一个风险：被另外一个相同名称的函数覆盖(<strong><span style="color: #339966;">override</span></strong>)了。</p>

<p>但是别担心，JavaScript语言允许callback函数在调用的时候才进行声明：</p>

<pre class="wp-code-highlight prettyprint linenums:1">foo
{
    function()
    {
        alert( &#039;hello, world&#039; );
    }
);</pre>


<p>在上面，可以看到这个callback实际上并没有标示(identifier)。它也不会存在于全局范围，因此也不会与别的已有函数产生冲突。</p>

<p>我们也可以把callback存储到一个变量中，同样也不回存在于全局范围，不过我们可以通过这个变量对这个callback进行重复利用：</p>

<pre class="wp-code-highlight prettyprint linenums:1">myCallback = function()
{
    alert( &#039;hello, world&#039; );
};

foo( myCallback );</pre>


<h3><strong><span style="color: #339966;"> 1.2闭包性</span></strong></h3>

<p>闭包性这个概念是允许一个函数访问其所声明上下文中的变量，甚至是在不同的运行上下文中。</p>

<p>下面我们再来看看JavaScript的相关代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">function foo( callback )
{
    alert( callback() );
}

function bar()
{
    var str = &#039;hello, world&#039;;

    foo
    (
        function()
        {
            return str;
        }
    );
}

bar();</pre>


<p>上面的代码中，callback被从bar函数的运行上下文中传递给了foo函数，该callback函数返回变量str的值。</p>

<p>不过在这里请注意，变量str是声明在bar函数中的，也就是说这个变量仅存于bar函数中。</p>

<p>而callback是在另外一个不同的函数中被执行的(跟变量str不在一起)，我们这是可能会猜测foo函数中什么也不会显示出来。</p>

<p>但是，在这里引入了闭包性这个概念。</p>

<p>也就是说在不同的函数中(运行上下文中)，一个函数可以访问到变量所声明上下文中的内容。</p>

<p>因此上面的代码中，callback可以访问到str变量——即使这个callback所在的foo函数不能直接访问这个str变量。</p>

<p>&nbsp;</p>

<h2><span style="color: #339966;"><strong>2、Objective-C中的实现</strong></span></h2>

<p>实际上闭包性和匿名函数在Objective-C中是可以使用的，只不过Objective-C是构建于C语言之上，属于强类型编译语言，所以跟上面介绍的解释性脚本语言有许多不同之处。</p>

<p>注意：block其实在纯C或C++(以及Objective-C++)中都是可用的。</p>

<p>在标准C函数中，定义block(匿名函数)之前需要先声明原型。</p>

<p>block的语法有一点点棘手，不过要是熟悉函数指针的话，就非常容易理解了。</p>

<p>下面是block的原型：</p>

<pre class="wp-code-highlight prettyprint linenums:1">NSString * ( ^ myBlock )( int );</pre>


<p>上面的代码是声明了一个block(^)原型，名字就叫做myBlock，携带一个int参数，返回只为NSString类型的指针。</p>

<p>下面来看看block的定义：</p>

<pre class="wp-code-highlight prettyprint linenums:1">myBlock = ^( int number )
{
    return [ NSString stringWithFormat: @"Passed number: %i", number ];
};</pre>


<p>如上所示，将一个函数体赋值给了myBlock变量，其接收一个名为number的参数。该函数返回一个NSString对象。</p>

<p><strong><span style="color: #ff0000;">注意：不要忘记block后面的分号。</span></strong></p>

<p>在脚本语言中是可以忽略掉分号的，但是在编译性语言(如Objective-C)是必须有的。</p>

<p>如果没有写这个分号，编译器会产生一个错误，当然也不会生成可执行文件。</p>

<p>定义好block之后，就可以像使用标准函数一样使用它了：</p>

<pre class="wp-code-highlight prettyprint linenums:1">myBlock(5);</pre>


<p>下面是完整的Objective-C程序源代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#import &lt;Cocoa/Cocoa.h&gt;

int main( void )
{
    NSAutoreleasePool * pool;
    NSString * ( ^ myBlock )( int );

    pool    = [ [ NSAutoreleasePool alloc ] init ];
    myBlock = ^( int number )
    {
        return [ NSString stringWithFormat: @"Passed number: %i", number ];
    };

    NSLog( @"%@", myBlock(5) );

    [ pool release ];

    return EXIT_SUCCESS;
}</pre>


<p>我们可以用下面的命令来编译(在Terminal中)：</p>

<pre class="wp-code-highlight prettyprint linenums:1">gcc -Wall -framework Cocoa -o test test.m</pre>


<p>上面的命令会根据test.m源代码文件生成一个名为name的可执行文件。可以用下面的命令来运行这个可执行文件：</p>

<pre class="wp-code-highlight prettyprint linenums:1">./test</pre>


<p>如果不把block赋值给变量的话，可以忽略掉block原型的声明，例如直接将block当做参数进行传递。如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">someFunction( ^ NSString * ( void ) { return @"hello, world" } );</pre>


<p>注意，上面这种情况必须声明返回值的类型——这里是返回NSString对象。</p>

<h3><span style="color: #339966;"><strong>2.1将block当做参数来传递</strong></span></h3>

<p>之前说过了，block可以当做参数传递给某个C函数。</p>

<p>如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">void logBlock( NSString * ( ^ theBlock )( int ) )
{
    NSLog( @"Block returned: %@", theBlock() );
}</pre>


<p>由于Objective-C是强制类型语言，所以作为函数参数的block也必须要指定返回值的类型，以及相关参数类型(如果需要的话)。</p>

<p>其实在Objective-C方法中也是一样的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- ( void )logBlock: ( NSString * ( ^ )( int ) )theBlock;</pre>


<h3><span style="color: #339966;"><strong>2.2闭包性</strong></span></h3>

<p>之前有说过，闭包性在Objective-C中是可用的，只不过其行为跟解释性语言有所不同罢了。</p>

<p>我们来看看下面的程序：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#import &lt;Cocoa/Cocoa.h&gt;

void logBlock( int ( ^ theBlock )( void ) )
{
    NSLog( @"Closure var X: %i", theBlock() );
}

int main( void )
{
    NSAutoreleasePool * pool;
    int ( ^ myBlock )( void );
    int x;

    pool = [ [ NSAutoreleasePool alloc ] init ];
    x    = 42;

    myBlock = ^( void )
    {
        return x;
    };

    logBlock( myBlock );

    [ pool release ];

    return EXIT_SUCCESS;
}</pre>


<p>上面的代码在main函数中声明了一个整型，并赋值42，另外还声明了一个block，该block会将42返回。</p>

<p>然后将block传递给logBlock函数，该函数会显示出返回的值42。</p>

<p>即使是在函数logBlock中执行block，而block又声明在main函数中，但是block仍然可以访问到x变量，并将这个值返回。</p>

<p><strong><span style="color: #ff0000;">注意：block同样可以访问全局变量，即使是static。</span></strong></p>

<p>下面来看看第一点不同之处：通过block进行闭包的变量是const的。也就是说不能在block中直接修改这些变量。</p>

<p>来看看当block试着增加x的值时，会发生什么：</p>

<pre class="wp-code-highlight prettyprint linenums:1">myBlock = ^( void )
{
    x++

    return x;
};</pre>


<p>编译器会生成一个错误：大概意思是在block中x变量是只读的。</p>

<p>不过也别担心，为了允许在block中修改变量，也是可以做到的：用__block关键字来声明变量即可。</p>

<p>基于之前的代码，给x变量添加__block关键字，如下：</p>

<pre class="wp-code-highlight prettyprint linenums:1">__block int x;</pre>


<h3><span style="color: #339966;"><strong>2.3内存管理</strong></span></h3>

<p>从C语言的角度来看，实际上block是一个结构体，可以被拷贝和销毁的。有两个函数可以使用：Block_copy和Block_destroy()。</p>

<p>而在Objective-C中，block可以接收retain、release和copie消息，这就跟普通对象一样。如果一个block需要被存储下来供以后使用，这些消息是非常重要的(例如，将block存储到一个类的实例变量中)。例如，为了避免错误的使用block，对block进行retain是非常有必要的。</p>

<p><span style="color: #339966;"><strong>2.4示例</strong></span></p>

<p>Block可以用在许多不同的环境中，这样可以让代码更加简单，以及减少函数声明的数量。</p>

<p>下面有一个实例：</p>

<p>我们将给NSArrary类添加一个static方法(类方法)，该方法通过一个callback，根据另外一个数组中的内容产生一个新的数组。</p>

<p>在PHP程序员眼里，该方法就如一个array_filter()。</p>

<p>首先，需要为NSArray类声明一个category。（通过category可以给已有的类添加新方法）。</p>

<pre class="wp-code-highlight prettyprint linenums:1">@interface NSArray( BlockExample )

+ ( NSArray * )arrayByFilteringArray: ( NSArray * )source withCallback: ( BOOL ( ^ )( id ) )callback;

@end</pre>


<p>上面，声明了一个方法，该方法返回一个NSArray对象，另外接收两个参数：NSArray对象，以及一个callback (为block)。</p>

<p>在callback中会判断根据传入数组参数中的每一个元素。并将返回一个boolean值，以确定当前array中的元素是否需要存储到返回的数组中。</p>

<p>block只有一个参数，代表数组中的某个元素。</p>

<p>我们来看看该方法的具体实现：</p>

<pre class="wp-code-highlight prettyprint linenums:1">@implementation NSArray( BlockExample )

+ ( NSArray * )arrayByFilteringArray: ( NSArray * )source withCallback: ( BOOL ( ^ )( id ) )callback
{
    NSMutableArray * result;
    id               element;

    result = [ NSMutableArray arrayWithCapacity: [ source count ] ];

    for( element in source ) {

        if( callback( element ) == YES ) {

            [ result addObject: element ];
        }
    }

    return result;
}

@end</pre>


<p>上面的代码中，首先是创建了一个可以动态改变尺寸的数组：NSMutableArray，然后根据source array的数目来初始化该数组。</p>

<p>然后对source array中的每个元素进行迭代， 如果callback返回值为YES的话，就将该元素添加到result数组中。</p>

<p>下面是使用该方法的一个完整示例：利用callback构建一个数组：该数组中只包含source array中为NSString类型的元素：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#import &lt;Cocoa/Cocoa.h&gt;

@interface NSArray( BlockExample )

+ ( NSArray * )arrayByFilteringArray: ( NSArray * )source withCallback: ( BOOL ( ^ )( id ) )callback;

@end

@implementation NSArray( BlockExample )

+ ( NSArray * )arrayByFilteringArray: ( NSArray * )source withCallback: ( BOOL ( ^ )( id ) )callback
{
    NSMutableArray * result;
    id               element;

    result = [ NSMutableArray arrayWithCapacity: [ source count ] ];

    for( element in source ) {

        if( callback( element ) == YES ) {

            [ result addObject: element ];
        }
    }

    return result;
}

@end

int main( void )
{
    NSAutoreleasePool * pool;
    NSArray           * array1;
    NSArray           * array2;

    pool   = [ [ NSAutoreleasePool alloc ] init ];
    array1 = [ NSArray arrayWithObjects: @"hello, world", [ NSDate date ], @"hello, universe", nil ];
    array2 = [ NSArray
                    arrayByFilteringArray: array1
                    withCallback:          ^ BOOL ( id element )
                    {
                        return [ element isKindOfClass: [ NSString class ] ];
                    }
             ];

    NSLog( @"%@", array2 );

    [ pool release ];

    return EXIT_SUCCESS;
}</pre>


<p>本文由<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-12</time></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度围观block：第三集]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/11/101/"/>
    <updated>2013-07-11T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/11/101</id>
    <content type="html"><![CDATA[<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/blocks1.png"><img class="alignnone size-full wp-image-1580" alt="blocks1" src="http://beyondvincent.com/wp-content/uploads/2013/07/blocks1.png" width="396" height="177" /></a></p>

<p>本文由<strong><span style="color: #339966;">破船</span></strong>译自<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/" target="_blank"><span style="color: #339966; text-decoration: underline;">galloway</span></a></span></strong></span>转载请注明出处！</p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>本文是深度围观block的第三篇文章，也是最后一篇。希望读者阅读了之后，对block有更加深入的理解，同时也希望之前对汇编语言恐惧或者陌生的读者转变看法，其实只要你用心去看，去学，很容易就搞懂的。</p>

<p>另外由于block具有闭包性，我们也可以将其当做匿名函数，所以大家如果想要了解更多关于OC中的闭包性和匿名函数就来看看这篇文章吧：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.xs-labs.com/en/archives/articles/objc-blocks/" target="_blank"><span style="color: #339966; text-decoration: underline;">Closure and anonymous functions in Objective-C</span></a></span></span></strong>。</p>

<!--more-->


<h2><strong><span style="color: #339966;">目录</span></strong></h2>

<ul>
<li><strong><span style="color: #339966;">介绍</span></strong></li>
<li><strong><span style="color: #339966;">已知内容</span></strong></li>
<li><strong><span style="color: #339966;">Block_copy()</span></strong></li>
<li><strong><span style="color: #339966;">Block_release()</span></strong></li>
<li><strong><span style="color: #339966;"><strong style="color: #333333;"><span style="color: #339966;">何去何从</span></strong></span></strong></li>
</ul>


<h3><strong><span style="color: #339966;">正文</span></strong></h3>

<h2><strong><span style="color: #339966;">介绍</span></strong></h2>

<p>本文话费了很长时间才出炉。实际上，几个月之前就已经打好草稿了，只不过一直忙于写我的这本书:<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.effectiveobjectivec.com/" target="_blank"><span style="color: #339966; text-decoration: underline;">Effective Objective-C 2.0</span></a></span></span></strong>，所以没有时间完成本文。</p>

<p>接着之前的两篇文章：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://beyondvincent.com/2013/07/09/%e6%b7%b1%e5%ba%a6%e5%9b%b4%e8%a7%82block%ef%bc%9a%e7%ac%ac%e4%b8%80%e9%9b%86/" target="_blank"><span style="color: #339966; text-decoration: underline;">深度围观block：第一集</span></a></span></span></strong>和<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://beyondvincent.com/2013/07/10/%e6%b7%b1%e5%ba%a6%e5%9b%b4%e8%a7%82block%ef%bc%9a%e7%ac%ac%e4%ba%8c%e9%9b%86/" target="_blank"><span style="color: #339966; text-decoration: underline;">深度围观block：第二集</span></a></span></span></strong>，本文将更进一步了解当block被拷贝时发生了什么。可能你已经听过这样的说辞“block开始于栈”，以及“如果你希望将block保存下来，以便后续使用，那么必须对block进行拷贝”。那么，这是为什么呢？而在拷贝过程中实际又会发生什么情况？我一直在思考拷贝block时是利用了什么机制。就如之前介绍的block在进行值拷贝时发生了什么。本文我将揭晓这些疑问。</p>

<h2><strong><span style="color: #339966;">已知内容</span></strong></h2>

<p>通过<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/2013/07/09/%e6%b7%b1%e5%ba%a6%e5%9b%b4%e8%a7%82block%ef%bc%9a%e7%ac%ac%e4%b8%80%e9%9b%86/" target="_blank"><span style="color: #339966; text-decoration: underline;">第一集</span></a></strong></span></span>和<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/2013/07/10/%e6%b7%b1%e5%ba%a6%e5%9b%b4%e8%a7%82block%ef%bc%9a%e7%ac%ac%e4%ba%8c%e9%9b%86/" target="_blank"><span style="color: #339966; text-decoration: underline;">第二集</span></a></strong></span></span>两篇文章，我们可以知道block的内存布局如下图所示：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/block_layout.png"><img class="alignnone size-full wp-image-1575" alt="block_layout" src="http://beyondvincent.com/wp-content/uploads/2013/07/block_layout.png" width="500" height="500" /></a></p>

<p>在<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://beyondvincent.com/2013/07/10/%e6%b7%b1%e5%ba%a6%e5%9b%b4%e8%a7%82block%ef%bc%9a%e7%ac%ac%e4%ba%8c%e9%9b%86/" target="_blank"><span style="color: #339966; text-decoration: underline;">第二集</span></a></strong></span></span>中，我们也知道了当block初始化的时候，会在栈中创建像上图这样的一个结构。由于这个结构是在栈上，而在栈空间是会被重复使用的。那么如果我们想要在以后继续使用该block，就必须要对block进行拷贝操作。拷贝操作需要调用<strong><span style="color: #339966;">Block_copy()</span></strong>函数，或者可以理解为给block发送一个<strong><span style="color: #339966;">copy</span></strong>消息(因为block可以看成一个Objective-C对象)，这也会调用<strong><span style="color: #339966;">Block_copy()</span></strong>函数。</p>

<p>下面我们就来看看Block_copy()函数都做了什么。</p>

<h2><strong><span style="color: #339966;">Block_copy()</span></strong></h2>

<p>我们首先来看看<strong><span style="color: #339966;">Block.h</span></strong>文件，在这里面可以看到如下定义：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#define Block_copy(...) ((__typeof(__VA_ARGS__))_Block_copy((const void *)(__VA_ARGS__)))

void *_Block_copy(const void *arg);</pre>


<p>可以看出，<strong><span style="color: #339966;">Block_copy()</span></strong>实际上就是一个宏定义(<strong><span style="color: #339966;">#define</span></strong>)，该宏定义将传入的参数(<strong><span style="color: #339966;">const void *</span></strong>)做强制类型转换，然后再传给<strong><span style="color: #339966;">_Block_copy()</span></strong>。我们也可以在实现文件<strong><span style="color: #339966;">runtime.c</span></strong>中找到<strong><span style="color: #339966;">_Block_copy()</span></strong>的原型：</p>

<pre class="wp-code-highlight prettyprint linenums:1">void *_Block_copy(const void *arg) {
    return _Block_copy_internal(arg, WANTS_ONE);
}</pre>


<p>上面的方法调用了<strong><span style="color: #339966;">_Block_copy_internal()</span></strong>函数，并传入block本身(arg)以及<strong><span style="color: #339966;">WANTS_ONE</span></strong>。要弄白具体意思，需要查看_Block_copy_internal方法的实现，该方法也是在<strong><span style="color: #339966;">runtime.c</span></strong>文件中。如下代码所示(已经去除掉了一些无关的内容：主要是垃圾回收相关)：</p>

<pre class="wp-code-highlight prettyprint linenums:1">static void *_Block_copy_internal(const void *arg, const int flags) {
    struct Block_layout *aBlock;
    const bool wantsOne = (WANTS_ONE & flags) == WANTS_ONE;

    // 1
    if (!arg) return NULL;

    // 2
    aBlock = (struct Block_layout *)arg;

    // 3
    if (aBlock-&gt;flags & BLOCK_NEEDS_FREE) {
        // latches on high
        latching_incr_int(&aBlock-&gt;flags);
        return aBlock;
    }

    // 4
    else if (aBlock-&gt;flags & BLOCK_IS_GLOBAL) {
        return aBlock;
    }

    // 5
    struct Block_layout *result = malloc(aBlock&gt;descriptor-&gt;size);
    if (!result) return (void *)0;

    // 6
    memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first

    // 7
    result-&gt;flags &= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
    result-&gt;flags |= BLOCK_NEEDS_FREE | 1;

    // 8
    result-&gt;isa = _NSConcreteMallocBlock;

    // 9
    if (result-&gt;flags & BLOCK_HAS_COPY_DISPOSE) {
        (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
    }

    return result;
}</pre>


<p>下面来看看该方法都做了些什么事情：</p>

<p>1、如果传入的参数是<strong><span style="color: #339966;">NULL</span></strong>则直接返回<strong><span style="color: #339966;">NULL</span></strong>。这样可以保证传入一个<strong><span style="color: #339966;">NULL</span></strong> block时函数的安全性。</p>

<p>2、将参数强制转换为一个指针，该指针指向一个<strong><span style="color: #339966;">Block_layout</span></strong>结构对象。实际上在<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/2013/07/09/%e6%b7%b1%e5%ba%a6%e5%9b%b4%e8%a7%82block%ef%bc%9a%e7%ac%ac%e4%b8%80%e9%9b%86/" target="_blank"><span style="color: #339966; text-decoration: underline;">第一集</span></a></span></span></strong>中就介绍了Block_layout结构：这是一个内部使用的数据结构，该结构组成一个block，其中包含一个block的实现函数，以及另外几个元数据。</p>

<p>3、 如果block的flags包含BLOCK_NEEDS_FREE，说明这是一个堆block(a heap block)。这种情况下，需要做的事情就是增加引用计数(reference count)，然后将同一个的block返回。</p>

<p>4、如果block是一个全局block(参考<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/2013/07/09/%e6%b7%b1%e5%ba%a6%e5%9b%b4%e8%a7%82block%ef%bc%9a%e7%ac%ac%e4%b8%80%e9%9b%86/" target="_blank"><span style="color: #339966; text-decoration: underline;">第一集</span></a></strong></span></span>)，那么不用做任何事情，直接返回同一个block即可——因为全局block是一个单例(singleton)。</p>

<p>5、如果到这一步了，可以肯定该block肯定被分配在栈上。这种情况，需要将block拷贝到堆上。这也是最有趣的一部分。首先是利用malloc()函数在堆上创建block对应size大小的内存空间。如果失败了，就返回<strong><span style="color: #339966;">NULL</span></strong>，否则继续往下执行。</p>

<p>6、 利用<strong><span style="color: #339966;">memmove()</span></strong>函数将分配在栈中的block按位拷贝至刚刚在堆上分配的空间中。按位拷贝可以确保block中的所有元数据都能准确的进行拷贝，例如block的descriptor。</p>

<p>7、接着需要更新一下block的flags。第一行代码是确保引用计数被设置为0。后面紧跟的注释表示这不是必须的——估计此时引用计数已经是0了。我猜测这行代码的作用是为了防止潜在的bug，会引起引用计数不为0的情况。第二行代码是设置<strong><span style="color: #339966;">BLOCK_NEEDS_FREE</span></strong>标志，这标示该block是一个堆block，当引用计数变为0时，需要<strong><span style="color: #339966;">free</span></strong>掉。后面紧跟的<strong><span style="color: #339966;">| 1</span></strong>是将block的引用计数设置为1。</p>

<p>8、将block的<strong><span style="color: #339966;">isa</span></strong>指针设置为 <span style="color: #339966;"><strong>_NSConcreteMallocBlock</strong></span>，这就意味着该block是一个堆block。</p>

<p>9、最后，如果block有一个拷贝辅助函数(a copy helper function)，那么就调用它。如果有必要的话，表一起会生成一个拷贝辅助函数。例如block需要拷贝对象的时候，拷贝辅助函数会retain住已经拷贝的对象。</p>

<p>思路很清晰吧！现在你应该知道当block被拷贝时会发什么了！下面还需要了解一下当release时又回发生什么？</p>

<h2><strong><span style="color: #339966;">Block_release</span></strong></h2>

<p>与Block_copy对应的是Block_release()。同样，Block_release()也是一个宏定义，如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#define Block_release(...) _Block_release((const void *)(__VA_ARGS__))</pre>


<p>实际上，跟<strong><span style="color: #339966;">Block_copy()</span></strong>类似，<strong><span style="color: #339966;">Block_release()</span></strong>会为我们把参数进行强制类型转换。这样开发者就不用亲自来处理转换的事情了。</p>

<p>下面我们来看看<strong><span style="color: #339966;">_Block_release()</span></strong>函数(为了看起来清晰点，我对代码重排了一下，并移除了垃圾回收相关的代码)：</p>

<pre class="wp-code-highlight prettyprint linenums:1">void _Block_release(void *arg) {
    // 1
    struct Block_layout *aBlock = (struct Block_layout *)arg;
    if (!aBlock) return;

    // 2
    int32_t newCount;
    newCount = latching_decr_int(&aBlock-&gt;flags) & BLOCK_REFCOUNT_MASK;

    // 3
    if (newCount &gt; 0) return;

    // 4
    if (aBlock-&gt;flags & BLOCK_NEEDS_FREE) {
        if (aBlock-&gt;flags & BLOCK_HAS_COPY_DISPOSE)(*aBlock-&gt;descriptor-&gt;dispose)(aBlock);
        _Block_deallocator(aBlock);
    }

    // 5
    else if (aBlock-&gt;flags & BLOCK_IS_GLOBAL) {
        ;
    }

    // 6
    else {
        printf("Block_release called upon a stack Block: %p, ignored\n", (void *)aBlock);
    }
}</pre>


<p>来看看他们都做了些什么：</p>

<p>1、 首先将参数强制转换为<strong><span style="color: #339966;">Block_layout</span></strong>结构。如果传入的是<strong><span style="color: #339966;">NULL</span></strong>，那么为了函数的安全起见，将直接返回。</p>

<p>2、将block的引用计数标志位减1(还记得<strong><span style="color: #339966;">Block_copy()</span></strong>中将这个引用计数标志位设置为1吗？)。</p>

<p>3、如果newCount大于0，说明还有别的对象引用了这个block，所以并不需要立即释放block，只需简单的返回即可。</p>

<p>4、否则，如果flags中包含<strong><span style="color: #339966;">BLOCK_NEEDS_FREE</span></strong>，那么说明这个block是分配到堆上的，并且如果引用计数为0，那么需要释放这个block。首先是调用了block的dispose辅助函数，该函数跟copy辅助函数相反，负责做相反的操作，例如释放掉所有在block中拷贝的变量等。最后使用<strong><span style="color: #339966;">_Block_deallocator</span></strong>函数释放掉block，如果你去<strong><span style="color: #339966;">runtime.c</span></strong>文件中看看，会发现该函数的尾部是一个指向<strong><span style="color: #339966;">free</span></strong>的函数指针，也就是释放掉<strong><span style="color: #339966;">malloc</span></strong>分配的内存。</p>

<p>5、如果block是全局的，那么什么事情也不用做。</p>

<p>6、如果代码执行到这里了，会发生一些奇怪的事情：因为正在尝试将栈上的block释放掉，所以这行代码是为了提醒开发者的。在程序实际运行过程中，永远不会看到这里的提示。</p>

<p>Coool！就是这些了，没有更多，也没有再复杂的东西了！</p>

<h2><strong><span style="color: #339966;">何去何从</span></strong></h2>

<p>本文也是我深度围观block的最后一篇。其中有一些内容也可也在我的这本书中找到：<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://www.effectiveobjectivec.com/" target="_blank"><span style="color: #339966; text-decoration: underline;">Effective Objective-C 2.0</span></a></strong></span></span>。这一系列文章介绍了如何有效的使用block，并且如果你对block感兴趣的话，这系列的内容也可以帮助你更加深入的了解block。</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-11</time></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度围观block：第二集]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/10/100/"/>
    <updated>2013-07-10T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/10/100</id>
    <content type="html"><![CDATA[<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/blocks.png"><img class="alignnone size-full wp-image-1571" alt="blocks" src="http://beyondvincent.com/wp-content/uploads/2013/07/blocks.png" width="561" height="233" /></a></p>

<p>本文由<strong><span style="color: #339966;">破船</span></strong>译自<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/" target="_blank"><span style="color: #339966; text-decoration: underline;">galloway</span></a></span></strong></span>转载请注明出处！</p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>今天翻译了第二篇，这个翻译是比较痛苦(其实不止这篇，所有的都是)， 不比单纯的阅读，许多地方需要查阅资料，并细心的遣词造句，还得注意词不达意的地方(例如文中的<strong><span style="color: #339966;">A block that captures scope</span></strong>我翻译为<strong><span style="color: #339966;">block的拷贝范围</span></strong>，总感觉缺了一些作者原意，功力有限啊)。所以，我劝大家要是能看原文尽量去看原文吧，我这翻译的权当参考。</p>

<!--more-->


<h2><strong><span style="color: #339966;">目录</span></strong></h2>

<ul>
<li><strong><span style="color: #339966;">介绍</span></strong></li>
<li><strong><span style="color: #339966;">block类型</span></strong></li>
<li><strong><span style="color: #339966;">block的拷贝范围</span></strong></li>
<li><strong><span style="color: #339966;">block拷贝对象的类型</span></strong></li>
<li><strong><span style="color: #339966;">何去何从</span></strong></li>
</ul>


<h3><strong><span style="color: #339966;">正文</span></strong></h3>

<h2><strong><span style="color: #339966;">介绍</span></strong></h2>

<p>本文接着上一篇文章(<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://beyondvincent.com/2013/07/09/%E6%B7%B1%E5%BA%A6%E5%9B%B4%E8%A7%82block%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%9B%86/" target="_blank"><span style="color: #339966; text-decoration: underline;">深度围观block：第一集</span></a></span></span></strong>)，继续从编译器的角度深度围观block。在本文中，将介绍block并不是一成不变的，以及block在栈上的构成。</p>

<h2><strong><span style="color: #339966;">block类型</span></strong></h2>

<p>在<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/2013/07/09/%E6%B7%B1%E5%BA%A6%E5%9B%B4%E8%A7%82block%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%9B%86/" target="_blank"><span style="color: #339966; text-decoration: underline;">第一篇</span></a></span></span></strong>文章中，我们已经看到block有一个<strong><span style="color: #339966;">_NSConcreteGlobalBlock</span></strong>这样的类。由于所有变量都是已知的，所以在编译期间，block的结构(structure)和描述(descriptor)都将全部被初始化。关于block这里有几种不同的类型，每种类型都有对应的类。为了简单起见，这里只考虑其中三种：</p>

<ol>
<li><strong><span style="color: #339966;">_NSConcreteGlobalBlock</span></strong>是定义一个全局的block，在编译器就已经完成相关初始化任务。这种类型的block不会涉及到任何拷贝，例如一个空的block。</li>
<li><strong><span style="color: #339966;">_NSConcreteStackBlock</span></strong>是一个分配在栈上的block。这里是所有最终被拷贝到堆(heap)上的block的开始。</li>
<li><strong><span style="color: #339966;">_NSConcreteMallocBlock</span></strong>是分配到堆(heap)上的block。拷贝完一个block之后，这就会结束。当block的引用计数变为0，该block就会被释放。</li>
</ol>


<h2><strong><span style="color: #339966;">block拷贝范围</span></strong></h2>

<p>这次我们来看看另外一些代码，如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#import &lt;dispatch/dispatch.h&gt;

typedef void(^BlockA)(void);
void foo(int);

__attribute__((noinline))
void runBlockA(BlockA block) {
    block();
}

void doBlockA() {
    int a = 128;
    BlockA block = ^{
        foo(a);
    };
    runBlockA(block);
}</pre>


<p>为了让block拷贝一些内容，上面的代码中调用了<strong><span style="color: #339966;">foo</span></strong>函数，并给这个函数传递了一个变量。再说一下，本文涉及到的汇编代码是与armv7相关指令。下面是其中一部分汇编指令：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.globl  _runBlockA
    .align  2
    .code   16                      @ @runBlockA
    .thumb_func     _runBlockA
_runBlockA:
    ldr     r1, [r0, #12]
    bx      r1</pre>


<p>上面的汇编代码与<strong><span style="color: #339966;">runBlockA</span></strong>函数相关，这跟第一篇文章中的相同——都是调用了block中的<strong><span style="color: #339966;">invoke</span></strong>函数。接着是<strong><span style="color: #339966;">doBlockA</span></strong>汇编代码，如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.globl  _doBlockA
    .align  2
    .code   16                      @ @doBlockA
    .thumb_func     _doBlockA
_doBlockA:
    push    {r7, lr}
    mov     r7, sp
    sub     sp, #24
    movw    r2, :lower16:(L__NSConcreteStackBlock$non_lazy_ptr-(LPC1_0+4))
    movt    r2, :upper16:(L__NSConcreteStackBlock$non_lazy_ptr-(LPC1_0+4))
    movw    r1, :lower16:(___doBlockA_block_invoke_0-(LPC1_1+4))
LPC1_0:
    add     r2, pc
    movt    r1, :upper16:(___doBlockA_block_invoke_0-(LPC1_1+4))
    movw    r0, :lower16:(___block_descriptor_tmp-(LPC1_2+4))
LPC1_1:
    add     r1, pc
    ldr     r2, [r2]
    movt    r0, :upper16:(___block_descriptor_tmp-(LPC1_2+4))
    str     r2, [sp]
    mov.w   r2, #1073741824
    str     r2, [sp, #4]
    movs    r2, #0
LPC1_2:
    add     r0, pc
    str     r2, [sp, #8]
    str     r1, [sp, #12]
    str     r0, [sp, #16]
    movs    r0, #128
    str     r0, [sp, #20]
    mov     r0, sp
    bl      _runBlockA
    add     sp, #24
    pop     {r7, pc}</pre>


<p>看看，这跟之前的代码有所不同了。看起来这不仅仅是从一个全局的符号中加载block，而且还做了额外的一些事情。乍一看这么多代码让人有点无从下手，不过认真看，还是很容易理解的。从上面的代码可以看出，编译器已经忽略了对代码排序的优化，为了方便阅读代码，我对上面的汇编代码重新进行排序(当然，请相信我，这不会影响任何功能)。下面是我重排好的代码效果：</p>

<pre class="wp-code-highlight prettyprint linenums:1">_doBlockA:
        // 1
        push    {r7, lr}
        mov     r7, sp

        // 2
        sub     sp, #24

        // 3
        movw    r2, :lower16:(L__NSConcreteStackBlock$non_lazy_ptr-(LPC1_0+4))
        movt    r2, :upper16:(L__NSConcreteStackBlock$non_lazy_ptr-(LPC1_0+4))
LPC1_0:
        add     r2, pc
        ldr     r2, [r2]
        str     r2, [sp]

        // 4
        mov.w   r2, #1073741824
        str     r2, [sp, #4]

        // 5
        movs    r2, #0
        str     r2, [sp, #8]

        // 6
        movw    r1, :lower16:(___doBlockA_block_invoke_0-(LPC1_1+4))
        movt    r1, :upper16:(___doBlockA_block_invoke_0-(LPC1_1+4))
LPC1_1:
        add     r1, pc
        str     r1, [sp, #12]

        // 7
        movw    r0, :lower16:(___block_descriptor_tmp-(LPC1_2+4))
        movt    r0, :upper16:(___block_descriptor_tmp-(LPC1_2+4))
LPC1_2:
        add     r0, pc
        str     r0, [sp, #16]

        // 8
        movs    r0, #128
        str     r0, [sp, #20]

        // 9
        mov     r0, sp
        bl      _runBlockA

        // 10
        add     sp, #24
        pop     {r7, pc}</pre>


<p>下面我们来看看这些代码都做了什么：</p>

<ol>
<li>开场白。首先将 <strong><span style="color: #339966;">r7</span></strong> push到栈上面——因为r7会被覆盖，而r7寄存器中的内容在跨函数调用时是需要用到的。<strong><span style="color: #339966;">lr</span></strong>是链接寄存器(link register)，该寄存器中存储着当这个函数返回时需要执行下一条指令的地址。接着mov这条指令的作用是把栈指针保存到r7<strong><span style="color: #339966;">寄存器</span></strong>中。</li>
<li>从栈指针所处位置开始减去24，也就是在栈空间上开辟24字节来存储数据。</li>
<li>这里涉及到的代码是为了对符号<strong><span style="color: #339966;">L__NSConcreteStackBlock$non_lazy_ptr</span></strong>进行寻址，由于跟pc(program counter)相关联，所以无论代码处于二进制文件中任何位置，当最终链接时，都能对该符号做到正确的寻址。</li>
<li>将值<strong><span style="color: #339966;">1073741824</span></strong>存储到栈指针 + 4 的位置。</li>
<li>将值<strong><span style="color: #339966;"></span></strong>存储到栈指针 + 8 的位置。现在，将要发生什么可能已经变得逐渐清晰了——在栈上创建了一个<strong><span style="color: #339966;">Block_layout</span></strong>结构的对象！到现在为止，已经设置了该结构的3个值：<strong><span style="color: #339966;">isa</span></strong>指针，<strong><span style="color: #339966;">flags</span></strong>和<strong><span style="color: #339966;">reserved</span></strong>值。</li>
<li>将<strong><span style="color: #339966;">___doBlockA_block_invoke_0</span></strong>存储至栈指针 + 12的位置。这是block结构中的<strong><span style="color: #339966;">invoke</span></strong>。</li>
<li>将<strong><span style="color: #339966;">___block_descriptor_tmp</span></strong>存储至栈指针 + 16的位置。这是block结构中的<strong><span style="color: #339966;">descriptor</span></strong>。</li>
<li>将值<strong><span style="color: #339966;">128</span></strong>存储到栈指针 + 20的位置。如果回头看看<strong><span style="color: #339966;">Block_layout</span></strong>结构，可以看到里面只应该有5个值。那么在这个block结构体后面存储的128是什么呢？——注意到这个<strong><span style="color: #339966;">128</span></strong>实际上就是在block中拷贝的变量的值。所以这肯定就是存储block使用到的值的地方——在<strong><span style="color: #339966;">Block_layout</span></strong>结构尾部。</li>
<li>现在栈指针指向了已经完成初始化之后的block结构，在这里的汇编指令是将栈指针装载到<strong><span style="color: #339966;">r0</span></strong>中，然后调用<strong><span style="color: #339966;">runBlockA</span></strong>函数。(记住：在ARM EABI中，<strong><span style="color: #339966;">r0</span></strong>中存储的内容被当做函数的第一个参数)。</li>
<li>最后将栈指针加上24，这样就能够把最开始减去的24(在栈上开辟的24位空间)收回来。接着将栈中的两个值pop到<strong><span style="color: #339966;">r7</span></strong>和<strong><span style="color: #339966;">pc</span></strong>寄存器中。这里pop到<strong><span style="color: #339966;">r7</span></strong>中的，跟最开始从r7中push至栈中的内容是一致的，而<strong><span style="color: #339966;">pc</span></strong>的值则是最开始push <strong><span style="color: #339966;">lr</span></strong>到栈中的值，这样当函数返回时，可以让CPU能够正确的继续执行后续指令。</li>
</ol>


<p>Cooool！如果你一直认真看到这里，那么相信你的收获已经非常多了！</p>

<p>下面我们再看看block中的invoke函数和descriptor。希望跟第一集中的不要有太大差别。如下汇编代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.align  2
    .code   16                      @ @__doBlockA_block_invoke_0
    .thumb_func     ___doBlockA_block_invoke_0
___doBlockA_block_invoke_0:
    ldr     r0, [r0, #20]
    b.w     _foo

    .section        __TEXT,__cstring,cstring_literals
L_.str:                                 @ @.str
    .asciz   "v4@?0"

    .section        __TEXT,__objc_classname,cstring_literals
L_OBJC_CLASS_NAME_:                     @ @"\01L_OBJC_CLASS_NAME_"
    .asciz   "\001P"

    .section        __DATA,__const
    .align  2                       @ @__block_descriptor_tmp
___block_descriptor_tmp:
    .long   0                       @ 0x0
    .long   24                      @ 0x18
    .long   L_.str
    .long   L_OBJC_CLASS_NAME_</pre>


<p>看着没错，跟第一集中的没多大区别。唯一不同的就是block descriptor中的<strong><span style="color: #339966;">size</span></strong>——现在是<strong><span style="color: #339966;">24</span></strong>(之前是<strong><span style="color: #339966;">20</span></strong>)。这是因为block拷贝了一个整型值，所以block的结构需要24个字节，而不再是标准的20个字节了。在之前的代码中，我们已经分析了在创建block时，多出的4个字节被添加到block结构的尾部。<br/>
在实际的block函数中，例如<strong><span style="color: #339966;">___doBlockA_block_invoke_0</span></strong>，可以看到从block结构尾部读取出相关值，如<strong><span style="color: #339966;">r0 + 20</span></strong>，就是在block中拷贝的变量。</p>

<h2><strong><span style="color: #339966;">block拷贝对象的类型</span></strong></h2>

<p>下面我们来看看如果block拷贝的是别的对象类型(例如 <strong><span style="color: #339966;">NSString</span></strong>)，而不是integer，会发生什么呢？如下代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#import &lt;dispatch/dispatch.h&gt;

typedef void(^BlockA)(void);
void foo(NSString*);

__attribute__((noinline))
void runBlockA(BlockA block) {
    block();
}

void doBlockA() {
    NSString *a = @"A";
    BlockA block = ^{
        foo(a);
    };
    runBlockA(block);
}</pre>


<p>由于<strong><span style="color: #339966;">doBlockA</span></strong>变化不大，所以在此不深入介绍。这里感兴趣的是根据上面代码创建的block descriptor结构：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.section        __DATA,__const
    .align  4                       @ @__block_descriptor_tmp
___block_descriptor_tmp:
    .long   0                       @ 0x0
    .long   24                      @ 0x18
    .long   ___copy_helper_block_
    .long   ___destroy_helper_block_
    .long   L_.str1
    .long   L_OBJC_CLASS_NAME_</pre>


<p>注意看上面的汇编代码中有指向两个函数(<strong><span style="color: #339966;"><em>__copy_helper_block</em></span></strong>和<strong><span style="color: #339966;"><em>__destroy_helper_block</em></span></strong>)的指针。下面是这两个函数的定义：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.align  2
    .code   16                      @ @__copy_helper_block_
    .thumb_func     ___copy_helper_block_
___copy_helper_block_:
    ldr     r1, [r1, #20]
    adds    r0, #20
    movs    r2, #3
    b.w     __Block_object_assign

    .align  2
    .code   16                      @ @__destroy_helper_block_
    .thumb_func     ___destroy_helper_block_
___destroy_helper_block_:
    ldr     r0, [r0, #20]
    movs    r1, #3
    b.w     __Block_object_dispose</pre>


<p>这里我先假设当block被拷贝和销毁时，都会调用这里的函数。那么被block拷贝的对象肯定会发生reatain和release。上面的代码中，可以看出如果r0和r1包含有效数据时，拷贝函数接收两个参数(<strong><span style="color: #339966;">r0</span></strong>和<strong><span style="color: #339966;">r1</span></strong>)。而销毁函数接收一个参数。可以看出所有的拷贝和销毁任务都应该是由<strong><span style="color: #339966;">__Block_object_assign</span></strong>和<strong><span style="color: #339966;">__Block_object_dispose</span></strong>两个函数完成的。这两个函数位于block的运行时代码中(是LLVM里面<strong><span style="color: #339966;">compiler-rt</span></strong>工程的一部分)。<br/>
如果你希望了解一下block运行时相关代码，可以来这里下载源码：<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://compiler-rt.llvm.org" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://compiler-rt.llvm.org">http://compiler-rt.llvm.org</a></span></a></span></span></strong>。特别关注一下里面的<strong><span style="color: #339966;">runtime.c</span></strong>文件。</p>

<h2><strong><span style="color: #339966;">何去何从</span></strong></h2>

<p>在下一集中我将调查<strong><span style="color: #339966;">Block_copy</span></strong>相关代码，并看看相关工作处理情况，以此来深度围观一下block运行时。通过下一集的学习，你也将会深入了解拷贝和销毁函数(也就是本文中我们刚刚看到的在block拷贝对象时使用的函数)。</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-10</time></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深度围观block：第一集]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/09/99/"/>
    <updated>2013-07-09T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/09/99</id>
    <content type="html"><![CDATA[<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/blocks_2x.png"><img class="alignnone size-full wp-image-1563" alt="blocks_2x" src="http://beyondvincent.com/wp-content/uploads/2013/07/blocks_2x.png" width="1140" height="420" /></a></p>

<p>&nbsp;</p>

<p>本文由<strong><span style="color: #339966;">破船</span></strong>译自<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1/" target="_blank"><span style="color: #339966; text-decoration: underline;">galloway</span></a></span></strong></span>转载请注明出处！</p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>还记得之前的两篇文章吗：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://beyondvincent.com/2013/06/19/ios%e6%b1%87%e7%bc%96%e6%95%99%e7%a8%8b%ef%bc%9aarm/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS汇编教程：ARM(1)</span></a></span></span></strong>和<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://beyondvincent.com/2013/06/20/ios%e6%b1%87%e7%bc%96%e6%95%99%e7%a8%8b%ef%bc%9aarm2/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS汇编教程：ARM(2)</span></a></span></strong></span>，里面介绍了Objective-C生成的汇编代码。本文介绍的内容也跟汇编相关，只不过是与block相关，如果对汇编有不了解的，可以先去看看那两篇带有启蒙性质的文章哟。本文将从汇编的角度来介绍block相关知识。另外，如果你对block还不了解的话，建议你先去看看我的上一篇文章：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://beyondvincent.com/2013/07/08/%e5%88%9d%e5%a7%8bblock/" target="_blank"><span style="color: #339966; text-decoration: underline;">初识block</span></a></span></span></strong>。</p>

<!--more-->


<p><strong style="font-size: 1.5em;"><span style="color: #339966;">目录：</span></strong></p>

<ul>
<li><strong><span style="color: #339966;">简介</span></strong></li>
<li><strong><span style="color: #339966;">基础知识</span></strong></li>
<li><strong><span style="color: #339966;">深入一个简单示例</span></strong></li>
<li><span style="color: #339966;"><b>源码在这里</b></span></li>
<li><span style="color: #339966;"><b>何去何从</b></span></li>
</ul>


<h3><strong><span style="color: #339966;">正文</span></strong></h3>

<h2><strong><span style="color: #339966;">简介</span></strong></h2>

<p>今天我们从编译器的角度观察一下block内部是如何工作的。这里说的block是指苹果为C语言增加的具有闭包性(closure)的一个功能，block已经是clang/LLVM编译器所支持的一部分了。我一直在想block是什么，以及它是如何奇迹般的出现在Objective-C对象中(开发者可以像处理实例对象一样，对block进行<strong><span style="color: #339966;">copy</span></strong>、<span style="color: #339966;"><strong>retain</strong></span>、<strong><span style="color: #339966;">release</span></strong>)。本文我首先深入的介绍一点关于block的那些事。</p>

<h2><strong><span style="color: #339966;">基础知识</span></strong></h2>

<p>用过block的开发者都知道，下面的代码就是一个block：</p>

<pre class="wp-code-highlight prettyprint linenums:1">void(^block)(void) = ^{
    NSLog(@"I&#039;m a block!");
};</pre>


<p>上面的代码中创建了一个名为<strong><span style="color: #339966;">block</span></strong>的变量，并把一个简单的block代码赋值给这个变量。代码很简单，不是吗？不！！！在这里我想要搞清楚编译器对这点代码都做了些什么。<br/>
更进一步，下面的代码我给block传递了一个变量：</p>

<pre class="wp-code-highlight prettyprint linenums:1">void(^block)(int a) = ^{
    NSLog(@"I&#039;m a block! a = %i", a);
};</pre>


<p>而下面的代码是从block中返回一个值：</p>

<pre class="wp-code-highlight prettyprint linenums:1">int(^block)(void) = ^{
    NSLog(@"I&#039;m a block!");
    return 1;
};</pre>


<p>作为一个封闭的包，block将所处的上下文封装到了block中：</p>

<pre class="wp-code-highlight prettyprint linenums:1">int a = 1;
void(^block)(void) = ^{
    NSLog(@"I&#039;m a block! a = %i", a);
};</pre>


<p>编译器对上面这些代码具体是如何处理的——这才是我所感兴趣的。</p>

<h2><strong><span style="color: #339966;">深入一个简单示例</span></strong></h2>

<p>首先我的思路是看看编译器是如何编译一个非常简单的block。来看看如下代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#import &lt;dispatch/dispatch.h&gt;

typedef void(^BlockA)(void);

__attribute__((noinline))
void runBlockA(BlockA block) {
    block();
}

void doBlockA() {
    BlockA block = ^{
        // Empty block
    };
    runBlockA(block);
}</pre>


<p>之所以要用上面这样的代码，是因为我想看看block是如何创建的，以及如何调用一个block。如果block的创建和调用都在一个函数里面，那么优化器(optimiser)可能会对代码做优化处理，导致我们看不到任何感兴趣的东西，所以我给<strong><span style="color: #339966;">runBlockA</span></strong>函数添加了<strong><span style="color: #339966;">noinline</span></strong>，这样优化器就不会在<strong><span style="color: #339966;">doBlockA</span></strong>函数中对runBlockA的调用做内联优化处理。</p>

<p>上面代码通过编译器编译之后(armv7，03)，会得到如下汇编指令：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.globl  _runBlockA
    .align  2
    .code   16                      @ @runBlockA
    .thumb_func     _runBlockA
_runBlockA:
@ BB#0:
    ldr     r1, [r0, #12]
    bx      r1</pre>


<p>上面的汇编代码是对应<strong><span style="color: #339966;">runBlockA</span></strong>函数——这相当的简单。注意观察之前的源码，可以知道这个函数只是简单的调用了block。在ARM EABI中，将<strong><span style="color: #339966;">r0</span></strong>(寄存器r0)设置为第一个参数。第一条指令(r1)是将存储在地址为<strong><span style="color: #339966;">r0 + 12</span></strong>的值装载到寄存器<strong><span style="color: #339966;">r1</span></strong>中。这可以理解为指针的解引用——读12个字节到寄存器中。然后跳转到这个地址执行后面的指令。注意，这里使用了<strong><span style="color: #339966;">r1</span></strong>，而<strong><span style="color: #339966;">r0</span></strong>没有被修改，仍然是原来的block。所以这里很有可能是利用第一个参数来调用block。<br/>
据此，可以确定block在结构中的一些排序规则：block被当做执行的函数时存储在某个结构中，并占据了12个字节。当传递一个block时，指向这些结构的一个指针被传递进来了。</p>

<p>下面来看看<strong><span style="color: #339966;">doBlockA</span></strong>函数：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.globl  _doBlockA
    .align  2
    .code   16                      @ @doBlockA
    .thumb_func     _doBlockA
_doBlockA:
    movw    r0, :lower16:(___block_literal_global-(LPC1_0+4))
    movt    r0, :upper16:(___block_literal_global-(LPC1_0+4))
LPC1_0:
    add     r0, pc
    b.w     _runBlockA</pre>


<p>OK，上面的代码也不复杂——这是关于pc(program counter)的相关加载。你可以将其看做是把变量<strong><span style="color: #339966;">___block_literal_global</span></strong>的地址加载到<strong><span style="color: #339966;">r0</span></strong>中。然后调用<strong><span style="color: #339966;">runBlockA</span></strong>函数。因为从之前的源码中，可以知道我们把block传递给了<strong><span style="color: #339966;">runBlockA</span></strong>，所以这里的<strong><span style="color: #339966;">___block_literal_global</span></strong>一定就是那个被传递的block对象了。<br/>
到目前为止，我们对上面的源码的运作有一些眉目了！不过这里的<strong><span style="color: #339966;">___block_literal_global</span></strong>是什么呢？继续看汇编代码，可以找到如下这样的内容：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.align  2                       @ @__block_literal_global
___block_literal_global:
    .long   __NSConcreteGlobalBlock
    .long   1342177280              @ 0x50000000
    .long   0                       @ 0x0
    .long   ___doBlockA_block_invoke_0
    .long   ___block_descriptor_tmp</pre>


<p>Cool！上面的汇编代码看起来像是一个结构体。在结构体中又5个值，每个值有4个字节(long)。这肯定就是<strong><span style="color: #339966;">RunBlockA</span></strong>调用中涉及到的那个block对象。再细看一下，12个字节所在处就像一个函数指针：<strong><span style="color: #339966;">___doBlockA_block_invoke_0</span></strong>。这也是<strong><span style="color: #339966;">runBlockA</span></strong>函数中跳转执行的那个分支(bx r1)。</p>

<h2></h2>

<p>那么上面的汇编代码中<strong><span style="color: #339966;">__NSConcreteGlobalBlock</span></strong>又是何物？OK，现在先不介绍这个，后面会做介绍哦！下面我们来看看另外两个感兴趣的东西：<strong><span style="color: #339966;">___doBlockA_block_invoke_0</span></strong>和<strong><span style="color: #339966;">___block_descriptor_tmp</span></strong>，这两个东东同样出现在了汇编代码中：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.align  2
    .code   16                      @ @__doBlockA_block_invoke_0
    .thumb_func     ___doBlockA_block_invoke_0
___doBlockA_block_invoke_0:
    bx      lr

    .section        __DATA,__const
    .align  2                       @ @__block_descriptor_tmp
___block_descriptor_tmp:
    .long   0                       @ 0x0
    .long   20                      @ 0x14
    .long   L_.str
    .long   L_OBJC_CLASS_NAME_

    .section        __TEXT,__cstring,cstring_literals
L_.str:                                 @ @.str
    .asciz   "v4@?0"

    .section        __TEXT,__objc_classname,cstring_literals
L_OBJC_CLASS_NAME_:                     @ @"\01L_OBJC_CLASS_NAME_"
    .asciz   "\001"</pre>


<p>上面的代码中<strong><span style="color: #339966;">___doBlockA_block_invoke_0</span></strong>看起来有点像block的实现部分，只不过这里的block是空的，所以会立即返回(刚开始我们就期望编译一个空的block哦)。<br/>
接着看看<strong><span style="color: #339966;">___block_descriptor_tmp</span></strong>。这里可以看到另外一个数据结构——有4个值。其中第2个是<strong><span style="color: #339966;">20</span></strong>，这表示<strong><span style="color: #339966;">___block_literal_global</span></strong>的大小。接着是一个名为<strong><span style="color: #339966;">.str</span></strong>的C字符串，它的值为<strong><span style="color: #339966;">v4@?0</span></strong>，看起来有点像某个类型的编码形式。这可能是block 类型的编码(例如返回void和不携带任何参数)。上面代码中别的一些值我暂时还不清楚。</p>

<h2><strong><span style="color: #339966;">源码在这里</span></strong></h2>

<p>没错，这里有源代码！这是LLVM中<strong><span style="color: #339966;">compiler-rt</span></strong>项目的一部分。查看代码，我发现在<span style="color: #339966;"><strong><span style="text-decoration: underline;"><a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/Block_private.h" target="_blank"><span style="color: #339966; text-decoration: underline;">Block_private.h</span></a></span></strong></span>文件中，有如下相关代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};

struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};</pre>


<p>这看起来很熟悉吧！其中<strong><span style="color: #339966;">Block_layout</span></strong>结构体就是<strong><span style="color: #339966;">___block_literal_global</span></strong>，而<strong><span style="color: #339966;">Block_descriptor</span></strong>结构体则是<strong><span style="color: #339966;">__block_descriptor_tmp</span></strong>。细看Block_descriptor中的第2个变量size正如我之前描述的一样(表示___block_literal_global的大小)。在<strong><span style="color: #339966;">Block_descriptor</span></strong>中的第3和第4个值有点奇怪。这看起来有点想函数指针，但是在上面的汇编代码中看起来更像是两个字符串。现在我忽略掉这个细节。</p>

<p><strong><span style="color: #339966;"> Block_layout</span></strong>中的<span style="color: #339966;"><strong>isa</strong></span>肯定就是<strong><span style="color: #339966;">__NSConcreteGlobalBlock</span></strong>，这也将确定block如何能够模拟Objective-C对象。如果<strong><span style="color: #339966;">__NSConcreteGlobalBlock</span></strong>是一个<strong><span style="color: #339966;">Class</span></strong>，那么Objective-C消息派送系统会将block对象当做一个普通的对象来处理。这跟如何处理toll-free bridging工作类似。更多相关toll-free bridging信息，可以阅读Mike Ash写的<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.mikeash.com/pyblog/friday-qa-2010-01-22-toll-free-bridging-internals.html" target="_blank"><span style="color: #339966; text-decoration: underline;">一篇优秀文章</span></a></span></span></strong>。</p>

<p>将所有的代码片段拼凑起来，编译器做的工作内容看起来如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#import &lt;dispatch/dispatch.h&gt;

__attribute__((noinline))
void runBlockA(struct Block_layout *block) {
    block-&gt;invoke();
}

void block_invoke(struct Block_layout *block) {
    // Empty block function
}

void doBlockA() {
    struct Block_descriptor descriptor;
    descriptor-&gt;reserved = 0;
    descriptor-&gt;size = 20;
    descriptor-&gt;copy = NULL;
    descriptor-&gt;dispose = NULL;

    struct Block_layout block;
    block-&gt;isa = _NSConcreteGlobalBlock;
    block-&gt;flags = 1342177280;
    block-&gt;reserved = 0;
    block-&gt;invoke = block_invoke;
    block-&gt;descriptor = descriptor;

    runBlockA(&amp;block);
}</pre>


<p>非常不错！通过上面的介绍，我们可以了解很多关于block内部的东西。</p>

<h2><strong><span style="color: #339966;">何去何从</span></strong></h2>

<p>下一步我将介绍携带一个参数的block，以及从封闭范围内拷贝一个变量的block。这些内容跟本文介绍的又稍显不同！期待吧！</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-09</time></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识block]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/08/98/"/>
    <updated>2013-07-08T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/08/98</id>
    <content type="html"><![CDATA[<p>本文由<strong><span style="color: #339966;">破船</span></strong>译自<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://rypress.com/tutorials/objective-c/blocks.html" target="_blank"><span style="color: #339966; text-decoration: underline;">rypress</span></a></span></span></strong>转载请注明出处！</p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>本周末微博上朋友发了一个关于block的MV，只能说老外太逗了。大家也可以去看看怎么回事：<a href="http://blog.bignerdranch.com/3001-cocoa-got-blocks/" target="_blank"> <strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;">Cocoa Got Blocks</span></span></strong></a>。虽然之前也有接触过block，不过没有深入完整的学习过，借此机会来学习一下，顺便翻译几篇block相关的文章，本文是第一篇，算是block的入门。本文的最后延伸阅读给出了4篇相关文章，不出意外的话，本周大家能看到对应的中文版。</p>

<!--more-->


<h2><strong><span style="color: #339966;">目录：</span></strong></h2>

<ul>
<li><strong><span style="color: #339966;">Block简介</span></strong></li>
<li><strong><span style="color: #339966;">Block的创建</span></strong></li>
<li><strong><span style="color: #339966;">不带参数的Block</span></strong></li>
<li><strong><span style="color: #339966;">Block的闭包性(closure)</span></strong></li>
<li><strong><span style="color: #339966;">修改非局部变量</span></strong></li>
<li><strong><span style="color: #339966;">Block作为函数的参数</span></strong></li>
<li><strong><span style="color: #339966;">定义Block类型</span></strong></li>
<li><strong><span style="color: #339966;">总结</span></strong></li>
<li><strong><span style="color: #339966;">延伸阅读</span></strong></li>
</ul>


<h3><strong><span style="color: #339966;">正文</span></strong></h3>

<h2><strong><span style="color: #339966;">Block简介</span></strong></h2>

<p>我们可以把Block当做Objective-C的匿名函数。Block允许开发者在两个对象之间将任意的语句当做数据进行传递，往往这要比引用定义在别处的函数直观。另外，block的实现具有封闭性(closure)，而又能够很容易获取上下文的相关状态信息。</p>

<hr />

<h2><strong><span style="color: #339966;">Block的创建</span></strong></h2>

<p>实际上，block使用了与<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://rypress.com/tutorials/objective-c/functions.html" target="_blank"><span style="color: #339966; text-decoration: underline;">函数</span></a></span></strong></span>相同的机制：可以像声明函数一样，来声明一个bock变量；可以利用定义一个函数的方法来定义一个block；也可以将block当做一个函数来调用。</p>

<pre class="wp-code-highlight prettyprint linenums:1">// main.m
#import &lt;Foundation/Foundation.h&gt;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // Declare the block variable
        double (^distanceFromRateAndTime)(double rate, double time);

        // Create and assign the block
        distanceFromRateAndTime = ^double(double rate, double time) {
            return rate * time;
        };
        // Call the block
        double dx = distanceFromRateAndTime(35, 1.5);

        NSLog(@"A car driving 35 mph will travel "
              @"%.2f miles in 1.5 hours.", dx);
    }
    return 0;
}</pre>


<p>在上面的代码中，利用插入符(^)将distanceFromRateAndTime变量标记为一个block。就像声明函数一样，需要包含返回值的类型，以及参数的类型，这样编译器才能安全的进行强制类型转换。插入符(^)跟指针(例如 int *aPointer)前面的星号(*)类似——只是在声明的时候需要使用，之后用法跟普通的变量一样。</p>

<p>block的定义本质上跟函数一样——只不过不需要函数名。block以签名字符串开始：<sup>double</sup>(double rate, double time)标示返回一个double，以及接收两个同样为double的参数(如果不需要返回值，可以忽略掉)。在签名后面是一个大括弧({})，在这个括弧里面可以编写任意的语句代码，这跟普通的函数一样。</p>

<p>当把block赋值给distanceFromRateAndTime后，我们就可以像调用函数一样调用这个变量了。</p>

<h2><strong><span style="color: #339966;">不带参数的Block</span></strong></h2>

<p>如果block不需要任何的参数，那么可以忽略掉参数列表。另外，在定义block的时候，返回值的类型也是可选的，所以这样情况下，block可以简写为^ { … }：</p>

<pre class="wp-code-highlight prettyprint linenums:1">double (^randomPercent)(void) = ^ {
    return (double)arc4random() / 4294967295;
};
NSLog(@"Gas tank is %.1f%% full",
      randomPercent() * 100);</pre>


<p>在上面的代码中，利用内置的<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="https://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man3/arc4random.3.html" target="_blank"><span style="color: #339966; text-decoration: underline;">arc4random()</span></a></span></span></strong>方法返回一个32位的整型随机数——为了获得0-1之间的一个值，通过除以arc4random()方法能够获取到的最大值(4294967295)。</p>

<p>到现在为止，block看起来可能有点像利用一种复杂的方式来定义一个方法。事实上，block是被设计为闭包的(closure)——这就提供了一种新的、令人兴奋的编程方式。</p>

<h2><strong><span style="color: #339966;">Block的闭包性(closure)</span></strong></h2>

<p>在block内部，可以像普通函数一样访问数据：局部变量、传递给block的参数，全局变量/函数。并且由于block具有<span style="color: #ff0000;"><strong>闭包性</strong></span>，所以还能访问<strong><span style="color: #ff0000;">非局部变量(non-local variable)</span></strong>。非局部变量定义在block之外，但是在block内部有它的作用域。例如，getFullCarName可以使用定义在block前面的make变量：</p>

<pre class="wp-code-highlight prettyprint linenums:1">NSString *make = @"Honda";
NSString *(^getFullCarName)(NSString *) = ^(NSString *model) {
    return [make stringByAppendingFormat:@" %@", model];
};
NSLog(@"%@", getFullCarName(@"Accord"));    // Honda Accord</pre>


<p>非局部变量会以const变量被拷贝并存储到block中，也就是说block对其是只读的。如果尝试在block内部给make变量赋值，会抛出编译器错误。</p>

<div id="attachment_1546" class="wp-caption alignnone" style="width: 340px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/07/const-non-local-variables.png"><img class="size-full wp-image-1546" alt="const-non-local-variables" src="http://beyondvincent.com/wp-content/uploads/2013/07/const-non-local-variables.png" width="330" height="170" /></a><p class="wp-caption-text">
    以const拷贝的方式访问非局部变量
  </p>
</div>


<p>&nbsp;</p>

<p>以const拷贝的方式访问非局部变量，意味着block实际上并不是真正的访问了非局部变量——只不过在block中创建了非局部变量的一个快照。当定义block时，无论非局部变量的值是什么，都将被冻结，并且block会一直使用这个值，即使在之后的代码中修改了非局部变量的值。下面通过代码来看看，在创建好block之后，修改make变量的值，会发生什么：</p>

<pre class="wp-code-highlight prettyprint linenums:1">NSString *make = @"Honda";
NSString *(^getFullCarName)(NSString *) = ^(NSString *model) {
    return [make stringByAppendingFormat:@" %@", model];
};
NSLog(@"%@", getFullCarName(@"Accord"));    // Honda Accord

// Try changing the non-local variable (it won&#039;t change the block)
make = @"Porsche";
NSLog(@"%@", getFullCarName(@"911 Turbo")); // Honda 911 Turbo</pre>


<p>block的闭包性为block与上下文交互的时候带来极大的便利性，当block需要额外的数据时，可以避免使用参数——只需要简单的使用非局部变量即可。</p>

<h2><strong><span style="color: #339966;">修改非局部变量</span></strong></h2>

<p>冻结中的非局部变量是一个常量值，这也是一种默认的安全行为——因为这可以防止在block中的代码对非局部变量做了意外的修改。那么如果我们希望在block中对非局部变量值进行修改要如何做呢——用__block存储修饰符(storage modifier)来声明非局部变量：</p>

<pre class="wp-code-highlight prettyprint linenums:1">__block NSString *make = @"Honda";</pre>


<p>这将告诉block对非局部变量做引用处理，在block外部make变量和内部的make变量创建一个直接的链接(direct link)。现在就可以在block外部修改make，然后反应到block内部，反过来，也是一样。</p>

<div id="attachment_1547" class="wp-caption alignnone" style="width: 270px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/07/mutable-non-local-variables.png"><img class="size-full wp-image-1547" alt="mutable-non-local-variables" src="http://beyondvincent.com/wp-content/uploads/2013/07/mutable-non-local-variables.png" width="260" height="150" /></a><p class="wp-caption-text">
    通过引用的方式访问非局部变量
  </p>
</div>


<p>这跟普通函数中的<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://rypress.com/tutorials/objective-c/functions.html#static-local-variables" target="_blank"><span style="color: #339966; text-decoration: underline;">静态局部变量(static local variable)</span></a></span></span></strong>类似，用__block修饰符声明的变量可以记录着block多次调用的结果。例如下面的代码创建了一个block，在block中对i进行累加。</p>

<pre class="wp-code-highlight prettyprint linenums:1">__block int i = 0;
int (^count)(void) = ^ {
    i += 1;
    return i;
};
NSLog(@"%d", count());    // 1
NSLog(@"%d", count());    // 2
NSLog(@"%d", count());    // 3</pre>


<h2></h2>

<h2><strong><span style="color: #339966;">Block作为函数的参数</span></strong></h2>

<p>把block存储在变量中有时候非常有用，比如将其用作函数的参数。这可以解决类似函数指针能解决的问题，不过我们也可以定义内联的block，这样代码更加易读。<br/>
例如下面Car interface中声明了一个方法，该方法用来计算汽车的里程数。这里并没有强制要求调用者给该方法传递一个常量速度，相反可以改方法接收一个block——该block根据具体的时间来定义汽车的速度。</p>

<pre class="wp-code-highlight prettyprint linenums:1">// Car.h
#import &lt;Foundation/Foundation.h&gt;

@interface Car : NSObject

@property double odometer;

- (void)driveForDuration:(double)duration
       withVariableSpeed:(double (^)(double time))speedFunction
                   steps:(int)numSteps;

@end</pre>


<p>上面代码中block的数据类型是double (^)(double time)，也就是说block的调用者需要传递一个double类型的参数，并且该block的返回值为double类型。注意：上面代码中的语法基本与本文开头介绍的block变量声明相同，只不过没有变量名字。<br/>
在函数的实现里面可以通过speedFunction来调用block。下面的示例通过算法计算出汽车行驶的大约距离。其中steps参数是由调用者确定的一个准确值。</p>

<pre class="wp-code-highlight prettyprint linenums:1">// Car.m
#import "Car.h"

@implementation Car

@synthesize odometer = _odometer;

- (void)driveForDuration:(double)duration
       withVariableSpeed:(double (^)(double time))speedFunction
                   steps:(int)numSteps {
    double dt = duration / numSteps;
    for (int i=1; i&lt;=numSteps; i++) {
        _odometer += speedFunction(i*dt) * dt;
    }
}

@end</pre>


<p>在下面的代码中，有一个main函数，在main函数中block定义在另一个函数的调用过程中。虽然理解其中的语法需要话几秒钟时间，不过这比起另外声明一个函数，再定义withVariableSpeed参数要更加直观。</p>

<pre class="wp-code-highlight prettyprint linenums:1">// main.m
#import &lt;Foundation/Foundation.h&gt;
#import "Car.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        Car *theCar = [[Car alloc] init];

        // Drive for awhile with constant speed of 5.0 m/s
        [theCar driveForDuration:10.0
               withVariableSpeed:^(double time) {
                           return 5.0;
                       } steps:100];
        NSLog(@"The car has now driven %.2f meters", theCar.odometer);

        // Start accelerating at a rate of 1.0 m/s^2
        [theCar driveForDuration:10.0
               withVariableSpeed:^(double time) {
                           return time + 5.0;
                       } steps:100];
        NSLog(@"The car has now driven %.2f meters", theCar.odometer);
    }
    return 0;
}</pre>


<p>上面利用一个简单的示例演示了block的通用性。在iOS的SDK中有许多API都利用了block的其它一些功能。<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/NSArray.html" target="_blank"><span style="color: #339966; text-decoration: underline;">NSArray</span></a></span></span></strong>的sortedArrayUsingComparator:方法可以使用一个block对元素进行排序，而<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/uiview_class/uiview/uiview.html" target="_blank"><span style="color: #339966; text-decoration: underline;">UIView</span></a></span></span></strong>的animateWithDuration:animations:方法使用了一个block来定义动画的最终状态。此外，block在并发编程中具有强大的作用。</p>

<h2><strong><span style="color: #339966;">定义Block类型</span></strong></h2>

<p>由于block数据类型的语法会很快把函数的声明搞得难以阅读，所以经常使用typedef对block的签名(signature)做处理。例如，下面的代码创建了一个叫做SpeedFunction的新类型，这样我们就可以对withVariableSpeed参数使用一个更加有语义的数据类型。</p>

<pre class="wp-code-highlight prettyprint linenums:1">// Car.h
#import &lt;Foundation/Foundation.h&gt;

// Define a new type for the block
typedef double (^SpeedFunction)(double);

@interface Car : NSObject

@property double odometer;

- (void)driveForDuration:(double)duration
       withVariableSpeed:(SpeedFunction)speedFunction
                   steps:(int)numSteps;

@end</pre>


<p>许多标准的Objective-C框架也使用了这样的技巧，例如<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_DataTypes/Reference/reference.html#//apple_ref/doc/c_ref/NSComparator" target="_blank"><span style="color: #339966; text-decoration: underline;">NSComparator</span></a></span></span></strong>。</p>

<h2><strong><span style="color: #339966;">总结</span></strong></h2>

<p>Block不仅提供了C函数同样的功能，而且block看起来更加直观。block可以定义为内联(inline)，这样在函数内部调用的时候就非常方便，由于block具有闭包性(closure)，所以block可以很容易获得上下文信息，而又不会对这些数据产生负面影响。</p>

<h2><strong><span style="color: #339966;">延伸阅读</span></strong></h2>

<ul>
<li><span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-1/" target="_blank"><span style="color: #339966; text-decoration: underline;">A look inside blocks: Episode 1</span></a></span></strong></span></li>
<li><span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/" target="_blank"><span style="color: #339966; text-decoration: underline;">A look inside blocks: Episode 2</span></a></span></strong></span></li>
<li><span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/" target="_blank"><span style="color: #339966; text-decoration: underline;">A look inside blocks: Episode 3 (Block_copy)</span></a></span></strong></span></li>
<li><span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.xs-labs.com/en/archives/articles/objc-blocks/" target="_blank"><span style="color: #339966; text-decoration: underline;">Closure and anonymous functions in Objective-C</span></a></span></strong></span></li>
</ul>


<p>&nbsp;</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-08</time></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[打造轻量化的View Controller]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/05/97/"/>
    <updated>2013-07-05T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/05/97</id>
    <content type="html"><![CDATA[<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/JC4Yc.png"><img class="alignnone size-full wp-image-1538" alt="JC4Yc" src="http://beyondvincent.com/wp-content/uploads/2013/07/JC4Yc.png" width="800" height="322" /></a></p>

<p>&nbsp;</p>

<p>本文由<strong><span style="color: #339966;">破船</span></strong>译自<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://www.objc.io/issue-1/lighter-view-controllers.html" target="_blank"><span style="color: #339966; text-decoration: underline;">objc</span></a></span></strong></span>转载请注明出处！</p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>很早以前就看到了这篇文章，该文是<strong><span style="color: #339966;">Lighter View Controllers</span></strong>中比较重要的一篇，来自<strong><span style="color: #339966;"><a href="http://www.objc.io/%EF%BC%8C">http://www.objc.io/%EF%BC%8C</a></span></strong>该站点的目标是致力于介绍Objective-C中最佳的实践技能和高级技术，以期刊的形式发表，每期一个主题，第一期就是以Lighter View Controllers为主。共有5篇文章，由于老破船精力有限，可能不会全部翻译，感兴趣的读者可以前往官方站点，进行阅读，千万别苦等破船进港时，万一等到花谢草枯了，可不好哟。</p>

<p><strong><span style="color: #339966;">友情提醒</span></strong>：大家平常除了写代码，会有锻炼身体吗？明天就是周末了，记得少加班，多锻炼身体哟，这周我只打了一次篮球，运动量有点少了，计划明天早上去跑10公里。</p>

<h2><span style="color: #ff0000;"><strong>本文目录如下：</strong></span></h2>

<ul>
<li><strong><span style="color: #339966;">简介</span></strong></li>
<li><strong><span style="color: #339966;">剥离Data Source和其它Protocols</span></strong></li>
<li><strong><span style="color: #339966;">将业务逻辑移至Model Layer</span></strong></li>
<li><strong><span style="color: #339966;">创建Store类</span></strong></li>
<li><strong><span style="color: #339966;">将Web Service逻辑移至Model Layer</span></strong></li>
<li><strong><span style="color: #339966;">将View代码移至View Layer</span></strong></li>
<li><strong><span style="color: #339966;">与别的对象进行通讯</span></strong></li>
<li><strong><span style="color: #339966;">小结</span></strong></li>
<li><strong><span style="color: #339966;">延伸阅读</span></strong></li>
</ul>


<h2><strong><span style="color: #339966;">简介</span></strong></h2>

<p>在iOS工程中，view controllers经常是最大的文件，引起这样的主要原因是开发者在view controllers中编写了大量非必须代码，实际上，view controllers可以重用其中的许多代码。下面我们就来看看，有什么好的办法可以对view controllers进行瘦身，加强代码的可重用性(reusable)，并将代码放到适当的地方。<br/>
提醒：本文涉及到的<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="https://github.com/objcio/issue-1-lighter-view-controllers" target="_blank"><span style="color: #339966; text-decoration: underline;">示例工程</span></a></span></strong></span>已经放到GitHub上了。</p>

<h2><strong><span style="color: #339966;">剥离Data Source和其它Protocols</span></strong></h2>

<p>对view controllers瘦身最佳的方法之一就是将UITableViewDataSource涉及到的代码从view controllers中抽取出来，并封装到自己的一个类中。如果不止在一个view controllers中使用到UITableViewDataSource，那么会提高封装出来这个类的可重用性。<br/>
译者注：此处有一个前提条件原作者没有说明，我们需要注意一下——这里的view controllers是使用到了UITableView。</p>

<p>下面我们来看一个例子，在上面给出的示例工程中，有一个类PhotosViewController，里面原本有如下3个方法：</p>

<pre class="wp-code-highlight prettyprint linenums:1"># pragma mark Pragma

- (Photo*)photoAtIndexPath:(NSIndexPath*)indexPath {
return photos[(NSUInteger)indexPath.row];
}

- (NSInteger)tableView:(UITableView*)tableView
numberOfRowsInSection:(NSInteger)section {
return photos.count;
}

- (UITableViewCell*)tableView:(UITableView*)tableView
cellForRowAtIndexPath:(NSIndexPath*)indexPath {
PhotoCell* cell = [tableView dequeueReusableCellWithIdentifier:PhotoCellIdentifier
forIndexPath:indexPath];
Photo* photo = [self photoAtIndexPath:indexPath];
cell.label.text = photo.name;
return cell;
}</pre>


<p>上面3个方法中都涉及到了数组，并且在最后一个方法中利用索引(indexPatha)给UITableViewCell指定了相应的图片(view controllers管理着这些图片资源)。下面我们就来试着把与数组相关的代码封装到我们自己的<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="https://github.com/objcio/issue-1-lighter-view-controllers/blob/master/PhotoData/ArrayDataSource.h" target="_blank"><span style="color: #339966; text-decoration: underline;">一个类</span></a></span></span></strong>中。<br/>
如下代码所示，这里通过一个block来配置UITableViewCell，当然，也可以使用delegate对UITableViewCell进行配置，这主要取决于开发者。</p>

<pre class="wp-code-highlight prettyprint linenums:1">@implementation ArrayDataSource

- (id)itemAtIndexPath:(NSIndexPath*)indexPath {
return items[(NSUInteger)indexPath.row];
}

- (NSInteger)tableView:(UITableView*)tableView
numberOfRowsInSection:(NSInteger)section {
return items.count;
}

- (UITableViewCell*)tableView:(UITableView*)tableView
cellForRowAtIndexPath:(NSIndexPath*)indexPath {
id cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier
forIndexPath:indexPath];
id item = [self itemAtIndexPath:indexPath];
configureCellBlock(cell,item);
return cell;
}

@end</pre>


<p>有了上面这个自定义的类，我们就可以把view controllers中的那3个方法移除掉，并创建自定义类的一个示例对象，然后将其设置为table view的data source，如下代码所示。</p>

<pre class="wp-code-highlight prettyprint linenums:1">void (^configureCell)(PhotoCell*, Photo*) = ^(PhotoCell* cell, Photo* photo) {
cell.label.text = photo.name;
};
photosArrayDataSource = [[ArrayDataSource alloc] initWithItems:photos
cellIdentifier:PhotoCellIdentifier
configureCellBlock:configureCell];
self.tableView.dataSource = photosArrayDataSource;</pre>


<p>现在，当每次希望将数组中的内容显示到table view中时，不必再考虑如何将index path映射到数组中的准确位置了，只需要重新上面的代码即可。另外，我们也可以在自定义类中，实现另外的一些方法(例如tableView:commitEditingStyle:forRowAtIndexPath:)，以共享给所有的table view controllers。</p>

<p>这也会带来一个好处：可以单独的对自定义的这个类进行测试，而不用担心要重新写一些测试代码。其实，如果我们写的代码跟这里的情况类似，那么也可以这样做。</p>

<p>今年我在工作中写的一个应用程序，大量使用了Core Data。我也创建了类似的类。该类实现了动画更新的所有逻辑，section header处理，以及相关删除操作等。你可以创建该类的一个示例，然后设置一下对其调用的方法，以及配置cell的一个block，剩下的任务就能自动处理了。</p>

<p>此外，上面介绍的这种方法可以延伸到别的protocols，这能够给程序开发中带来很大的灵活性。例如UICollectionViewDataSource，在开发过程中，如果希望用UICollectionView替换已有的UITableView，我们几乎不需要对view controllers做很大的改动，甚至还能使我们的data source同时支持两种protocols(UITableViewDataSource和UICollectionViewDataSource)。</p>

<h2><strong><span style="color: #339966;">将业务逻辑移至Model Layer</span></strong></h2>

<p>下面的示例代码(另外一个工程)位于view controller，作用是找出针对用户active priority的一个列表。</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)loadPriorities {
NSDate* now = [NSDate date];
NSString* formatString = @"startDate &lt;= %@ AND endDate &gt;= %@";
NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now];
NSSet* priorities = [self.user.priorities filteredSetUsingPredicate:predicate];
self.priorities = [priorities allObjects];
}</pre>


<p>实际上，如果把这个方法移至User类的一个category中，会让代码更加清晰。此时，在View Controller.m文件中看起来应该是这样的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)loadPriorities {
self.priorities = [user currentPriorities];
}

而在User+Extensions.m中则如下代码：
- (NSArray*)currentPriorities {
NSDate* now = [NSDate date];
NSString* formatString = @"startDate &lt;= %@ AND endDate &gt;= %@";
NSPredicate* predicate = [NSPredicate predicateWithFormat:formatString, now, now];
return [[self.priorities filteredSetUsingPredicate:predicate] allObjects];
}</pre>


<p>实际开发中，有一些代码很难将其移至model对象中，但是，很明显这些代码与model是相关的，针对这样的情况，我们可以单独为其写一个类，例如下面的store类。</p>

<h2><strong><span style="color: #339966;">创建Store类</span></strong></h2>

<p>本文给出示例工程的第一版代码中，有一部分代码是用来从文件中加载数据，并对其进行解析的，这些代码是在view controller中：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)readArchive {
NSBundle* bundle = [NSBundle bundleForClass:[self class]];
NSURL *archiveURL = [bundle URLForResource:@"photodata"
withExtension:@"bin"];
NSAssert(archiveURL != nil, @"Unable to find archive in bundle.");
NSData *data = [NSData dataWithContentsOfURL:archiveURL
options:0
error:NULL];
NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];
_users = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@"users"];
_photos = [unarchiver decodeObjectOfClass:[NSArray class] forKey:@"photos"];
[unarchiver finishDecoding];
}</pre>


<p>实际上，view controller不应该关心这些事情的。在示例工程中，我创建了一个Store类来做这些事情——通过将这些代码从view controller中剥离出来，不仅可以对其重用和单独测试，另外还能对view controller瘦身。Store类专注于数据的加载、缓存，以及对数据库进行配置。这里的Store也经常叫做service layer或者repository。</p>

<h2><strong><span style="color: #339966;">将Web Service逻辑移至Model Layer</span></strong></h2>

<p>这里的方法实际上跟上面介绍的非常类似：不要在view controller中做web service逻辑处理，而是将相关的逻辑处理封装到不同的类中。然后我们的view controller通过callback handler(例如一个completion block)来调用这些类的方法。<br/>
这样做带来的一个好处就是我们可以方便在这些封装类中做缓存和错误处理。</p>

<h2><strong><span style="color: #339966;">将View代码移至View Layer</span></strong></h2>

<p>切记不要在view controller中构建复杂的view结构。可选方案是：要么利用interface builder，或者就是将view的构建封装到一个UIView子类中。例如，如果你要构建一个date picker控件，可以基于DatePickerView类来构建，而不要把所有构建逻辑都放入view controller中。这样不仅能增加控件的可重用性，还能让代码简单化。<br/>
如果你喜欢用interface builder，那么也同样可以在interface builder中做这些事情。我们的一些开发者可能认为只有view controller才能在interface builder中使用，其实我们可以通过加载一个单独的nib文件，来加载我们在nib文件中定制的view。在本文给出的示例工程中，我创建了一个PhotoCell.xib文件，该文件中定制了一个photo cell：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/photocell.png"><img class="alignnone size-full wp-image-1539" alt="photocell" src="http://beyondvincent.com/wp-content/uploads/2013/07/photocell.png" width="1168" height="838" /></a></p>

<p>如上图所示，我在这个view中创建了两个属性：photoDateLable和photoTitleLable(注意：在这里的xib文件中没有使用File&#8217;s Owner object)，并将这两个属性连接到制定的subview中。<br/>
上面介绍的技巧同样可以方便的用于别的一些custom view。</p>

<h2><strong><span style="color: #339966;">与别的对象进行通讯</span></strong></h2>

<p>在view controller中与别的view controller、model和view通讯是非常频繁的。虽然这确实是由controller负责的，不过，我们还是希望用最少的代码来完成相关的事情。<br/>
目前已经有许多技术可以用于view controller和model对象之间的通讯(例如KVO)，不过view controller之间通讯的技术貌似不太明朗。<br/>
我们可能会经常遇到这样的问题：一个view controller有许多状态需要与其它多个view controller进行勾兑。通常，需要把这些状态封装到一个单独的对象中，然后将其传送到对应的view controller中，在这些view controller中对这些状态进行观察并修改即可——这样带来的优点是所有的状态都在一个地方，开发者不用纠结于delegate的callback。<br/>
实际上，关于对象间的通讯是一个复杂的topic，在今后的文章中，我们可能会对其进行深度分析。<span style="color: #339966;"><br /> </span></p>

<h2><strong><span style="color: #339966;">小结</span></strong></h2>

<p>上面我们学习了一些对view controller瘦身的技巧。这些技巧并不强求用与所有的地方，其实只有一个目标：编写可维护的代码。大家通过了解这些方法，可以知道有更多的方法来应对复杂的view controller，让其看起来更加清晰。</p>

<h2><strong><span style="color: #339966;">延伸阅读</span></strong></h2>

<ul>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://developer.apple.com/library/ios/#featuredarticles/ViewControllerPGforiPhoneOS/BasicViewControllers/BasicViewControllers.html"><span style="color: #339966; text-decoration: underline;">View Controller Programming Guide for iOS</span></a></span></span></li>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/DevPedia-CocoaCore/ControllerObject.html"><span style="color: #339966; text-decoration: underline;">Cocoa Core Competencies: Controller Object</span></a></span></span></li>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://subjective-objective-c.blogspot.de/2011/08/writing-high-quality-view-controller.html"><span style="color: #339966; text-decoration: underline;">Writing high quality view controllers</span></a></span></span></li>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://programmers.stackexchange.com/questions/184396/mvcs-model-view-controller-store"><span style="color: #339966; text-decoration: underline;">Stack Overflow: Model View Controller Store</span></a></span></span></li>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://speakerdeck.com/trianglecocoa/unburdened-viewcontrollers-by-jay-thrash"><span style="color: #339966; text-decoration: underline;">Unburdened View Controllers</span></a></span></span></li>
<li><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://programmers.stackexchange.com/questions/177668/how-to-avoid-big-and-clumsy-uitableviewcontroller-on-ios"><span style="color: #339966; text-decoration: underline;">Stack Overflow: How to avoid big and clumsy UITableViewControllers on iOS</span></a></span></span></li>
</ul>


<p>&nbsp;</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-05</time></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Windows 8开发31日]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/03/96/"/>
    <updated>2013-07-03T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/03/96</id>
    <content type="html"><![CDATA[<h1>关于Windows 8开发31日翻译</h1>

<p>Windows 8 开发31日(31 Days of Windows 8)是由Jeff Blankenburg和Clark Sell原创的。</p>

<p>官方站点：<a href="http://31daysofwindows8.com/">http://31daysofwindows8.com/</a></p>

<p>涉及到两个版本： XAML/C#（由Jeff Blankenburg撰写） HTML5/JS （由Clark Sell撰写）</p>

<p>其中涉及到的资源和相关代码请到这里下载： <a href="https://github.com/csell5/31DaysOfWindows8">https://github.com/csell5/31DaysOfWindows8</a></p>

<p>在这里，由于破船对HTML5/JS不熟悉，所以只翻译XAML/C#相关主题。建议大家前往看原创内容，如果看不明白，再来这里看我翻译的相关内容。如果翻译不正确的地方，可以通过下面的联系方式告诉破船。</p>

<p>&nbsp;</p>

<h1>译文下载地址：<span style="text-decoration: underline;"><strong><span style="color: #ff0000; text-decoration: underline;"><a href="https://github.com/BeyondVincent/31-Days-of-Windows-8" target="_blank"><span style="color: #ff0000; text-decoration: underline;">第二版</span></a><span style="font-size: 13px;"><br /> </span></span></strong></span></h1>

<h1><span style="font-size: 13px;">2012年曾在</span><a style="font-size: 13px;" href="http://www.devdiv.com/forum.php"><a href="http://www.devdiv.com/forum.php">http://www.devdiv.com/forum.php</a></a><span style="font-size: 13px;"> 社区发布过第一版。根据读者的反馈，对第一版中的内容做了一些更新修正。</span></h1>

<h1>联系破船</h1>

<p>你可以发邮件与破船取得联系: <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x42;&#x65;&#121;&#x6f;&#110;&#100;&#x56;&#105;&#110;&#x63;&#x65;&#x6e;&#x74;&#x40;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;">&#x42;&#x65;&#121;&#111;&#x6e;&#x64;&#86;&#x69;&#110;&#x63;&#x65;&#x6e;&#116;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a></p>

<p>还可以关注破船的微博: 新浪微博:<a href="http://www.weibo.com/beyondvincent">www.weibo.com/beyondvincent</a></p>

<p>这里是破船的个人博客，欢迎光临：<a href="http://beyondvincent.com/">http://beyondvincent.com/</a></p>

<p>破船祝你阅读愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7新特征汇总[06]What&#8217;s New in Cocoa Touch学习笔记]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/03/95/"/>
    <updated>2013-07-03T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/03/95</id>
    <content type="html"><![CDATA[<p>提醒：这里是新特征汇总博文链接：<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/2013/06/11/ios7%E6%96%B0%E7%89%B9%E5%BE%81%E6%B1%87%E6%80%BB/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总</span></a></strong></span></span></p>

<p>今晚看了一下WWDC2013的session：<strong><span style="color: #ff0000;">What&#8217;s New in Cocoa Touch</span></strong></p>

<p>该session介绍了iOS 7中Cocoa Touch里面新增的许多内容。</p>

<p>下面是一些学习笔记，供大家参考一下（<strong><span style="color: #339966;">由于是边看边记录，如有文字录入错误，还请见谅</span></strong>）：</p>

<h2><strong><span style="color: #339966;">1、Multitasking</span></strong></h2>

<p><span style="color: #339966;">Background fetching</span><br/>
you must call this at launch<br/>
<span style="color: #339966;">Remote notification</span><br/>
Method: didReceiveRemoteNotification<br/>
call the completion handler when fetch is complete<br/>
<span style="color: #339966;">Background transfers</span><br/>
Method: handleEventsForBackgroundURLSession<br/>
NSURLSession replace API for NSURLConnection<br/>
Data upload download task<br/>
session have identifiers</p>

<h2><strong><span style="color: #339966;">2、view and image</span></strong></h2>

<p><span style="color: #339966;"> Image Rendering Modes</span><br/>
Creating image with redering mode<br/>
method: imageWithRenderingMode:<br/>
param: UIImageRenderingMode<br/>
<span style="color: #339966;">Tint</span><br/>
New UIView property<br/>
@property (nonatomic, retain) UIColor *tintColor;<br/>
Dimming adjustment behavior<br/>
@property (nonatomic) UIViewTintAdjustmentMode tintAdjustmentMode;<br/>
Finding out about changes<br/>
&ndash;(void) intColorDidChange;<br/>
<span style="color: #339966;">View Animation</span><br/>
No animations!<br/>
+(void)performWithoutAnimation:<br/>
Keyframes<br/>
+(void)animationKeyframesWithDuration<br/>
+(void)addKeyframeWithRelativeStartTime:<br/>
UIViewKeyframeAnimationOptions</p>

<h2><strong><span style="color: #339966;">3、Motion Effects</span></strong></h2>

<p>Applies relative values to key paths of a target view<br/>
Affected by device &#8220;pose&#8221; or position<br/>
Affects animatable properties only</p>

<p>class: UIInterpolatingMotionEffect<br/>
initialization——initWithKeyPath:<br/>
UIMotionEffect<br/>
abstract superclass<br/>
one method<br/>
keyPathsAndRelativeValuesForViewerOffset:<br/>
UIOffset: CGFloat horizontal, vertical;<br/>
<span style="color: #339966;">UIView</span><br/>
adding and removing motion effects<br/>
addMotionEffect:<br/>
removeMotionEffect:<br/>
@property (copy, nonatomic) NSArray *motionEffects;</p>

<h2><strong><span style="color: #339966;">4、Collection Views</span></strong></h2>

<p><span style="color: #339966;"> Transitions between layouts</span><br/>
method: setCollectionViewLayout: animated: completion<br/>
<span style="color: #339966;">UICollectionViewTransitionLayout</span></p>

<h2><strong><span style="color: #339966;">5、View Controllers</span></strong></h2>

<p><span style="color: #339966;"> Layout</span><br/>
wantsFullScreenLayout<br/>
deprecated in iOS 7.0<br/>
extended edges<br/>
content size<br/>
@property (nonatomic) CGSize preferredContentSize;<br/>
status bar appearance<br/>
new behavior for the status bar<br/>
new status bar style<br/>
UIStatusBarStyleDefault<br/>
UIStatusBarStyleLightContent (new)<br/>
// UIStatusBarStyleBlackTranslucent<br/>
// UIStatusBarStyleBlackOpaque</p>

<h2><strong><span style="color: #339966;">6、Custom Transitions</span></strong></h2>

<p>bounded &#8220;canned&#8221; transition<br/>
interactive, user-driven transition<br/>
new delegate method on UIViewController<br/>
UIViewControllerTransitioningDelegate<br/>
UIViewControllerAnimatedTransitioning<br/>
UIViewControllerInteractiveTransitioning<br/>
UIViewControllerContextTransitioning<br/>
ref: WWDC2013 Custom Transitions Using View Controllers</p>

<h2><strong><span style="color: #339966;">7、State Restoration</span></strong></h2>

<p><span style="color: #339966;"> Ignoring Snapshots</span><br/>
&ndash;(void)ignoreSnapshotOnNextApplicationLaunch;<br/>
<span style="color: #339966;">Other Objects</span><br/>
Non-view and non-view controller can now participate<br/>
method: registerObjectForStateRestoration:<br/>
<span style="color: #339966;">Bluetooth State Restoration</span></p>

<h2><strong><span style="color: #339966;">8、AirDrop</span></strong></h2>

<p>Adopt <span style="color: #339966;">UIActivityItemSourceProtocol</span><br/>
Update application&#8217;s info.plist to create, register, and export UTI for custom document formats<br/>
New Documents/Inbox directory</p>

<p><strong style="font-size: 1.5em;"><span style="color: #339966;">9、Dynamics</span></strong></p>

<p><span style="color: #339966;"><span style="color: #333333;">Fluid, responsive animations</span></span></p>

<p>Enhances the interactions in you application<br/>
Concentration on behaviors</p>

<p>class: UIDynamicAnimator<br/>
UIDynamicBehavior<br/>
UIDynamicItem</p>

<p><span style="color: #339966;">supported behaviors</span><br/>
UIAttachmentBehavior<br/>
UICollisionBehavior<br/>
UIGravityBehavior<br/>
UIPushBehavior<br/>
UISnapBehavior<br/>
UDynamicItemBehavior</p>

<h2><strong><span style="color: #339966;">10、Text</span></strong></h2>

<p><span style="color: #339966;"> Dynamic type sizing</span><br/>
@property(nonatomic, readonly) NSString * preferredContentSizeCategory;<br/>
<span style="color: #339966;">UIFont</span><br/>
Font scaling based on content size category<br/>
preferredFontForTextStyle:<br/>
<span style="color: #339966;">Text Kit</span><br/>
Objective-C API<br/>
class: NSTextStorage<br/>
NSLayoutManager<br/>
NSTextContainer<br/>
UITextView UITextField UILable<br/>
additional class<br/>
NSTextAttachment</p>

<h2><strong><span style="color: #339966;">11、More New Feathures</span></strong></h2>

<p><span style="color: #339966;"> Multipeer Connectivity</span><br/>
Local network discovery<br/>
seesion management<br/>
encryptyed sessions<br/>
file transfers<br/>
<span style="color: #339966;">SpriteKit</span><br/>
iOS 、OS X<br/>
High-performance sprite-based game framework<br/>
image atlas support<br/>
UIKit and AppKit integration<br/>
<span style="color: #339966;">Game Controller</span><br/>
Buttons<br/>
Analog joysticks<br/>
Multiple controllers<br/>
<span style="color: #339966;">MapKit</span><br/>
Directions<br/>
3D cameras<br/>
Map tile overlays<br/>
Map snapshots<br/>
Geodesic polylines</p>

<p><span style="color: #339966;">CoreLocation</span><br/>
Bluetooth LE beacons<br/>
advertising<br/>
ranging<br/>
New region types<br/>
Region monitoring<br/>
<span style="color: #339966;">Accessibility</span><br/>
Guided Access API<br/>
<span style="color: #339966;">GameCenter</span><br/>
new turn-based game API<br/>
turns tabs<br/>
mode for bidding<br/>
leader board improvements<br/>
system integrity features</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-03</time></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让UIViewController中的viewDidLoad和viewWillAppear各司其责]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/02/94/"/>
    <updated>2013-07-02T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/02/94</id>
    <content type="html"><![CDATA[<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://thejoeconwayblog.wordpress.com/2013/06/25/uiviewcontroller-viewdidload-vs-viewwillappear/" target="_blank"><span style="color: #339966; text-decoration: underline;">thejoeconwayblog</span></a></span></strong></span></p>

<p>你是否有过这样的感觉：有时某些代码是放到<strong><span style="color: #339966;">viewDidLoad</span></strong>还是<span style="color: #339966;"><strong>viewWillAppear</strong></span>:中，这很容易让人混淆。在Stack Overflow上经常会遇到这样的问题：<strong><span style="color: #339966;">viewDidLoad和viewWillAppear到底哪个方法先被调用？</span></strong>实际上，理解这些方法的去向，以及为什么会这样并不重要，重要的是需要知道这些方法的作用，以及它们是如何与程序协调分工的。</p>

<p>我们知道，一般iOS应用程序都是由多个view controller构成的，每个view controller代表一个屏幕的信息。而当程序与用户交互时，根据程序中不同的状态，显示不同的view controller。例如，如果用户需要注册一个账号时，屏幕上应该显示出允许用户输入个人信息的界面，当用户完成注册之后，应该能够看到相应的主页面。</p>

<p><strong><span style="color: #339966;">viewWillAppear:方法的作用是与屏幕中改变的内容进行交互。</span></strong>告诉view controller将对应的界面内容显示到屏幕最前端：确保view controller中所有的文本控件显示出最新的信息、必要的数据是可访问的、并对适当的通知(notification)进行观察等。当viewWillAppear:被触发时，说明对应的view controller变为&#8221;active&#8221;状态。</p>

<p><strong><span style="color: #339966;">那么viewDidLoad方法存在的理由又是什么呢？</span></strong>唯一的原因——有时无法或者不能有效的在XIB文件中对用户界面进行100%的配置。例如，有时希望给view设置一个特殊的属性(该属性在XIB中不可用)、有时在给一个button设置背景图片之前，希望能先对该图片进行修改、再比如，在使用auto layout时，有时你可能会意识到在XIB中进行相关操作还不如用代码来写auto layout相关的代码。</p>

<p>我们不能根据viewDidLoad方法的调用情况，来推断出应用程序的状态相关信息。viewDidLoad方法实际上就是简单的一个文件加载后处理机制。换句话说，作为开发者，应该<span style="color: #339966;"><strong>把viewDidLoad方法当做XIB文件的一个有效扩展</strong></span>，而不要理解为应用程序运转流程中的一部分。</p>

<p>这到底是什么意思呢？——我们应该在viewWillAppear:方法中对view中显示的内容进行变更，而不是在viewDidLoad中。view中的内容是程序实际运行时由controller传递给view来显示的数据(模型对象)。</p>

<p>下面我们来看一个示例：一个银行应用程序，可以显示用户当前的余额。当用户点击一个按钮时，可以在一个modal view controller中显示一个列表：该列表列出了用户附近的ATM机。在此，为了获得附近的ATM机列表信息，程序必须使用core location已经web service请求。在上面这种情况下，如果程序员把从服务器请求用户附近ATM列表的操作放到viewDidLoad中。此时，由于view controller只显示一次(viewDidLoad和viewWillAppear都只会被调用一次)，所以，从服务器请求用户附近ATM列表的操作，放到viewDidLoad与viewWillAppear中，对程序的效果都是一样的。</p>

<p>但是这样做法是不好的。想一下，如果把这个ATM view controller移到tab bar controller中，会是什么情况。现在，ATM view controller——在viewDidLoad中获取ATM信息的代码只会获取一次。所以，如果你周二在亚特兰大打开该程序查找ATM，然后查询一下余额。接着周三你去了纽约，再次打开该程序时，只能看到亚特兰大的ATM信息——view已经加载过了，所以不会再调用viewDidLoad方法。<br/>
<strong><span style="color: #ff0000;">注意：在这里应该有这样的前提条件：程序没有退出。</span></strong></p>

<p>实际上，在这种情况下，写代码时犯下了一个最大的错误：<strong><span style="color: #339966;">the easiest way is the easiest way</span></strong>。应用程序是会发生变化的，而用户界面也会发生改变。刚开始使用简单的方法，可能会在以后引发各种问题。</p>

<div style="text-align: left;">
  <span style="color: #808080;">本文由<strong><span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></strong>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-02</time></span>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode中断点的威力]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/07/01/93/"/>
    <updated>2013-07-01T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/07/01/93</id>
    <content type="html"><![CDATA[<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.albertopasca.it/whiletrue/2013/06/xcode-power-of-breakpoints/" target="_blank"><span style="color: #339966; text-decoration: underline;">albertopasca</span></a></span></strong></span><br/>
本文由<strong><span style="color: #339966;">HoNooD</span></strong>在<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://iosfeed.com/view/76" target="_blank"><span style="color: #339966; text-decoration: underline;">iosfeed</span></a></span></span></strong>站点上做了推荐。</p>

<p>这里先推荐两篇Xcode相关的文章：<br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/2013/05/31/xcode-code-snippets/" target="_blank"><span style="color: #339966; text-decoration: underline;">Xcode Code Snippets</span></a></span></span></strong><br/>
<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"> <a href="http://beyondvincent.com/2013/05/16/ios%E4%B8%AD%E8%B0%83%E8%AF%95-%E5%9F%BA%E6%9C%AC%E6%8A%80%E5%B7%A7/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS调试 — 基本技巧</span></a></span></span></strong></p>

<p>本文目录：</p>

<p><strong><span style="color: #339966;">1、添加一个特殊的断点</span></strong><br/>
<strong><span style="color: #339966;">    异常断点(Exception breakpoint)</span></strong><br/>
<strong><span style="color: #339966;">    符号断点(Symbolic breakpoint)</span></strong><br/>
<strong><span style="color: #339966;">2、打印到控制台</span></strong><br/>
<strong><span style="color: #339966;">    使用NSLog打印字符串</span></strong><br/>
<strong><span style="color: #339966;">    使用NSLog打印对象(po)</span></strong><br/>
<strong><span style="color: #339966;">    带条件的打印</span></strong><br/>
<strong><span style="color: #339966;">    在循环里面打印一些东西</span></strong><br/>
<strong><span style="color: #339966;">3、运行时设置断点</span></strong><br/>
<strong><span style="color: #339966;">4、调试中播放声音</span></strong><br/>
<strong><span style="color: #339966;">5、LLDB中有用的一些命令</span></strong><br/>
<strong><span style="color: #339966;">    打印帮助</span></strong><br/>
<strong><span style="color: #339966;">    打印调用栈</span></strong><br/>
<strong><span style="color: #339966;">    打印最基本的内容 (p)</span></strong><br/>
<strong><span style="color: #339966;">    打印对象(po)</span></strong><br/>
<strong><span style="color: #339966;">    打印表达式(expr)</span></strong><br/>
<strong><span style="color: #339966;">    打印线程中的一些东西</span></strong></p>

<p>&nbsp;</p>

<p>正文</p>

<p>下面是非常有用的一些Xcode调试技术(使用断点和LLDB调试器)</p>

<p>1、添加一个特殊的断点</p>

<ul>
<li>异常断点(Exception breakpoint)</li>
</ul>


<p>如果添加了异常断点，当程序每次发生了异常，都会被中断。<strong><span style="color: #339966;">一般用来捕获未知异常</span></strong>。如下示例：</p>

<pre class="wp-code-highlight prettyprint linenums:1">*** Terminating app due to uncaught exception ’NSRangeException’, reason:
’-[__NSCFArray objectAtIndex:]: index (10) beyond bounds (3)</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-01.png"><img class="alignnone size-full wp-image-1497" alt="xcode-debug-01" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-01.png" width="1049" height="654" /></a></p>

<ul>
<li>符号断点(Symbolic breakpoint)</li>
</ul>


<p>符号断点可以中断某个函数的调用。</p>

<pre class="wp-code-highlight prettyprint linenums:1">- [UIViewController viewDidLoad]
- [__NSCFArray objectAtIndex:]</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-02.png"><img class="alignnone size-full wp-image-1498" alt="xcode-debug-02" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-02.png" width="1049" height="654" /></a></p>

<p>&nbsp;</p>

<p>2、打印到控制台</p>

<ul>
<li>使用NSLog打印字符串</li>
</ul>


<p>使用断点来替换NSLog代码(或者在运行时添加一个NSLog)——与代码写NSLog的效果相同。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-04.png"><img class="alignnone size-full wp-image-1499" alt="xcode-debug-04" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-04.png" width="1030" height="654" /></a></p>

<p>&nbsp;</p>

<ul>
<li>使用NSLog打印对象(po)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">NSLog(@"obj: %@", obj);</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-05.png"><img class="alignnone size-full wp-image-1500" alt="xcode-debug-05" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-05.png" width="1030" height="654" /></a></p>

<ul>
<li>带条件的打印</li>
</ul>


<p>例如：当aNumber大于10才打印出“str”的内容。</p>

<pre class="wp-code-highlight prettyprint linenums:1">expr (void)NSLog(@"Ok, print a log: %@", str)</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-07.png"><img class="alignnone size-full wp-image-1501" alt="xcode-debug-07" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-07.png" width="1030" height="681" /></a></p>

<p>&nbsp;</p>

<ul>
<li>在循环里面打印一些东西</li>
</ul>


<p>例如，在循环中希望i大于5才开始打印。</p>

<pre class="wp-code-highlight prettyprint linenums:1">for ( int i=0; i&lt;10; i++ )
{
[self self]; // something
}</pre>


<p>使用“ignore”值，并利用下面的代码进行打印：</p>

<pre class="wp-code-highlight prettyprint linenums:1">expr (void)NSLog(@"Ok, print a log: %@", str)</pre>


<p><img class="alignnone size-full wp-image-1502" alt="xcode-debug-08" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-08.png" width="1030" height="681" /></p>

<p>3、运行时设置断点</p>

<p>在运行的时候，根据条件设置断点有时候非常有用。</p>

<pre class="wp-code-highlight prettyprint linenums:1">breakpoint set -f APViewController.m -l 33</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-09.png"><img class="alignnone size-full wp-image-1503" alt="xcode-debug-09" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-09.png" width="1030" height="681" /></a></p>

<p>4、调试中播放声音</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/Schermata-06-2456470-alle-15.43.13.png"><img class="alignnone size-full wp-image-1504" alt="Schermata-06-2456470-alle-15.43.13" src="http://beyondvincent.com/wp-content/uploads/2013/07/Schermata-06-2456470-alle-15.43.13.png" width="475" height="304" /></a></p>

<p>5、LLDB中有用的一些命令</p>

<p>当Xcode停留在某个断点时，我们可以通过控制台(console)与<strong><span style="color: #339966;">lldb</span></strong>进行交互。</p>

<ul>
<li>打印帮助</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) help</pre>


<ul>
<li>打印调用栈(bt)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) bt
* thread #1: tid = 0x1c03, 0x00003146 Debug`-[APViewController callMe:andANumber:](self=0x07187e50, _cmd=0x000038b9, str=0x0715aa40, aNum=38) + 230 at APViewController.m:33, stop reason = breakpoint 3.1
frame #0: 0x00003146 Debug`-[APViewController callMe:andANumber:](self=0x07187e50, _cmd=0x000038b9, str=0x0715aa40, aNum=38) + 230 at APViewController.m:33
frame #1: 0x0000304a Debug`-[APViewController viewDidLoad](self=0x07187e50, _cmd=0x005c5a77) + 122 at APViewController.m:16
frame #2: 0x000f41c7 UIKit`-[UIViewController loadViewIfRequired] + 536
frame #3: 0x000f4232 UIKit`-[UIViewController view] + 33
frame #4: 0x000433d5 UIKit`-[UIWindow addRootViewControllerViewIfPossible] + 66
frame #5: 0x0004376f UIKit`-[UIWindow _setHidden:forced:] + 368
frame #6: 0x00043905 UIKit`-[UIWindow _orderFrontWithoutMakingKey] + 49
frame #7: 0x0004c917 UIKit`-[UIWindow makeKeyAndVisible] + 65
frame #8: 0x00002e1b Debug`-[APAppDelegate application:didFinishLaunchingWithOptions:](self=0x07560750, _cmd=0x005a9c21, application=0x0716a640, launchOptions=0x00000000) + 571 at APAppDelegate.m:28
frame #9: 0x00010157 UIKit`-[UIApplication _handleDelegateCallbacksWithOptions:isSuspended:restoreState:] + 266
frame #10: 0x00010747 UIKit`-[UIApplication _callInitializationDelegatesForURL:payload:suspended:] + 1248
frame #11: 0x0001194b UIKit`-[UIApplication _runWithURL:payload:launchOrientation:statusBarStyle:statusBarHidden:] + 805
frame #12: 0x00022cb5 UIKit`-[UIApplication handleEvent:withNewEvent:] + 1022
frame #13: 0x00023beb UIKit`-[UIApplication sendEvent:] + 85
frame #14: 0x00015698 UIKit`_UIApplicationHandleEvent + 9874
frame #15: 0x01becdf9 GraphicsServices`_PurpleEventCallback + 339
frame #16: 0x01becad0 GraphicsServices`PurpleEventCallback + 46
frame #17: 0x01c06bf5 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 53
frame #18: 0x01c06962 CoreFoundation`__CFRunLoopDoSource1 + 146
frame #19: 0x01c37bb6 CoreFoundation`__CFRunLoopRun + 2118
frame #20: 0x01c36f44 CoreFoundation`CFRunLoopRunSpecific + 276
frame #21: 0x01c36e1b CoreFoundation`CFRunLoopRunInMode + 123
frame #22: 0x0001117a UIKit`-[UIApplication _run] + 774
frame #23: 0x00012ffc UIKit`UIApplicationMain + 1211
frame #24: 0x00002b22 Debug`main(argc=1, argv=0xbffff3a4) + 130 at main.m:16
frame #25: 0x00002a55 Debug`start + 53
(lldb)</pre>


<ul>
<li>打印最基本的内容 (p)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) print anInt</pre>


<ul>
<li>打印对象(po)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) po anObj
(lldb) po 0x0715aa40</pre>


<ul>
<li>打印表达式(expr)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) expr 5+2
(lldb) expr aString = @"aNewValue"</pre>


<ul>
<li>打印线程中的一些东西</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) help frame</pre>




<div style="text-align: left;">
  <span style="color: #808080;">本文由<strong><span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></strong>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-01</time></span>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记我的第二个马拉松—昆明高原国际半程马拉松]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/06/21/92/"/>
    <updated>2013-06-21T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/06/21/92</id>
    <content type="html"><![CDATA[<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>对于IT行业的从业人员，由于工作的性质，很多人的身体都缺乏有效的锻炼。实际上这是一个非常危险的信号，现如今，随着社会的进步，大家的生活质量也不断提高，但是人们的身体状况总是令人担忧，几乎每年都能听说在IT行业里面有关猝死的新闻！在这里，希望大家能够在工作之余，善待自己的身体——毕竟前人已经说过，身体是革命的本钱！相信现在对身体多一份投资，将来会得到更多的回报。</p>

<p>关于技术的分享改日再谈，今日就来跟大家分享一下我的第二个马拉松。</p>

<h2><strong><span style="color: #339966;">正文</span></strong></h2>

<p>细算我跑步也有些年头了，不过要算马拉松比赛，至今才参加了2个，第一个是2012年11月25日的<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://beyondvincent.com/2013/05/11/%E7%A0%B4%E8%88%B9%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%97%E4%BA%AC%E9%A9%AC%E6%8B%89%E6%9D%BE/" target="_blank"><span style="color: #339966; text-decoration: underline;">北京国际马拉松</span></a></span></strong></span>，现在还记得，本应该10月中旬就举办的了，但是由于要召开十八大，所以北京马拉松被迫让路，被推延到11月25日举行，在北京生活过的同学们应该清楚，这时候的天气已经冷了，这给我的初马带来了不小的挑战，结果虽然完成了比赛，但是跟预期的时间要多了1小时30分钟左右。</p>

<p>今年(2013)回到了云南，从云南跑吧群里得知在5月25日将举办昆明高原国际半程马拉松，大家也没有盼来期望的全程，可能组委会考虑到近一年来马拉松赛场上出的那些事，为谨慎起见吧。虽然是半程，不过这是在高原，平均海拔在1800米，对于外省人来说估计也会有一些难度。刚好，目前全程对于我来说可以跑下来，不过身体会受伤，半程是我的最佳选择。</p>

<p>为了参加昆明的这个马拉松，我前前后后约准备了半年时间，当然，由于是半程，难度不是太大，不出意外，都能够完赛，所以在备战计划中，对自己的身体要求不是太苛刻，力争达到跑完比赛之后，身体还是舒服就好。因而在平常的训练中，每周平均跑步3.5次，每次跑步的距离也是随性，可能是8km，10km，有时也会只计算时间，速度和距离没有考虑太多。毕竟跑步的最终目的是锻炼身体，让疾病晚一点光顾，参加马拉松比赛对我而言只当做锦上添花罢了，也算是给平时的跑步生活增添一点乐趣。</p>

<p>2013年5约25日，我早早的就起床，赶往马拉松出发地点——昆明-呈贡新区。到达出发点时，已经有好多人了，也看到了好多张熟悉的面孔。由于排队上厕所耗费了一些时间，没能赶上云南跑吧的赛前大合影（来自跑吧风11的摄影），有点点遗憾。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb.jpeg"><img class="alignnone size-full wp-image-1476" alt="psb" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb.jpeg" width="5428" height="1469" /></a></p>

<p>早上9点，马拉松准备开始，刚开始，当然也是中国式的马拉松开幕式——领导发言，10分钟后准时鸣枪起跑。大家像挣脱缰绳的野马一样，无论是男女老少，都一波流的往前冲，我在想，照着么快的速度下去，很多人会中途跑崩了的。也或许没有全程，大家顾虑也会少了许多吧。</p>

<p>本次马拉松的一大特点应该就是赛道起伏坡度又大又长，这跟北京马拉松的赛道有明显的区别。这对平时不怎么跑坡的同学，也会增加一点难度。</p>

<p>在跑步途中，我主要以匀速跟随跑为主，为了控制好自己的速度，时不时的会问问周围跑友目前的配速。由于本次赛道是折返跑，所以开跑后大约在8km的地方，我遇到了已经折返的<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://blog.sina.com.cn/mlwdxlbk42195" target="_blank"><span style="color: #339966; text-decoration: underline;">马哥-千里马</span></a></span></strong></span>——马拉松业余爱好者中的佼佼者，也为云南跑吧的成长付出了很多。</p>

<div id="attachment_1477" class="wp-caption alignnone" style="width: 272px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130621-1.png"><img class="size-full wp-image-1477" alt="马哥-千里马" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130621-1.png" width="262" height="316" /></a><p class="wp-caption-text">
    马哥-千里马
  </p>
</div>


<p>大约跑了50分钟的时候，我开始从折返点往回跑，一路上遇到好多熟悉的，不熟悉的人，大家相互加油，共同奔跑。</p>

<div id="attachment_1478" class="wp-caption alignnone" style="width: 1610px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb-1.jpeg"><img class="size-full wp-image-1478" alt="psb (1)" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb-1.jpeg" width="1600" height="1060" /></a><p class="wp-caption-text">
    破船在折返途中
  </p>
</div>


<p>折返途中，也是有几个不小的坡，前几个都轻松搞定，就是最后一个坡，这个坡度虽然不大，但是太长了，在距离终点还有2km的时候，心里做了数次挣扎——跑不动就走走吧，但是又在鼓励自己，坚持住，跑过地狱就是天堂。就这样，坚持着，很快，拐过几个弯，终点处的计时牌已经映入眼帘，看看时间，能够跑进2小时。最后时刻，在观众的加油声中，肾上腺激素被激发，加快了脚下的速度，顺利冲过终点，而此时时间定格在1小时56分42秒，排名141名。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb.png"><img class="alignnone size-full wp-image-1479" alt="psb" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb.png" width="533" height="575" /></a></p>

<p>冲过终点，领取纪念奖品，然后跟云南跑吧一起合影</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb1.jpeg"><img class="alignnone size-full wp-image-1480" alt="psb" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb1.jpeg" width="1114" height="539" /></a></p>

<p>&nbsp;</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb-11.jpeg"><img class="alignnone size-full wp-image-1481" alt="psb (1)" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb-11.jpeg" width="665" height="492" /></a></p>

<p>&nbsp;</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/psb-2.jpeg"><img class="alignnone size-full wp-image-1482" alt="psb (2)" src="http://beyondvincent.com/wp-content/uploads/2013/06/psb-2.jpeg" width="800" height="535" /></a></p>

<p>下一站：云南大理马拉松</p>

<div style="text-align: left;">
  <span style="color: #808080;">本文由<span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-21</time></span>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS汇编教程：ARM(2)]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/06/20/91/"/>
    <updated>2013-06-20T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/06/20/91</id>
    <content type="html"><![CDATA[<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.raywenderlich.com/37181/ios-assembly-tutorial" target="_blank"><span style="color: #339966; text-decoration: underline;">raywenderlich</span></a></span></strong></span><br/>
感谢<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://blog.devtang.com/" target="_blank"><span style="color: #339966; text-decoration: underline;">唐巧</span></a></strong></span></span>抽出时间对本文进行double-check。</p>

<p>本文是iOS汇编教程：ARM第二篇。</p>

<p>iOS汇编教程：ARM目录如下[共分为两篇]：</p>

<h2><span style="text-decoration: underline;"><a href="http://beyondvincent.com/?p=1398" target="_blank"><strong><span style="color: #339966; text-decoration: underline;">iOS汇编教程：ARM(1)</span></strong></a></span></h2>

<ul>
<li><strong><span style="color: #339966;">开始：什么是汇编</span></strong></li>
<li><strong><span style="color: #339966;">函数调用约定</span></strong></li>
<li><strong><span style="color: #339966;">创建工程</span></strong></li>
<li><strong><span style="color: #339966;">加法(addFunction)</span></strong></li>
</ul>


<h2><strong><span style="color: #339966;">iOS汇编教程：ARM(2)</span></strong></h2>

<ul>
<li><strong><span style="color: #339966;">函数的调用</span></strong></li>
<li><strong><span style="color: #339966;">Objective -C 汇编</span></strong></li>
<li><strong><span style="color: #339966;">Obj-C 消息发给了谁</span></strong></li>
<li><strong><span style="color: #339966;">你现在可以进行逆向工程了</span></strong></li>
<li><strong><span style="color: #339966;">何去何从</span></strong></li>
</ul>


<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&ndash;</p>

<h1><span style="color: #339966;"><strong>iOS汇编教程：ARM(2)</strong></span></h1>

<h2><strong><span style="color: #339966;">函数的调用</span></strong></h2>

<p>首先，给函数addFunction函数添加一个属性(<strong><span style="color: #339966;"><strong>attribute</strong></span></strong>) ，告诉编译器不要进行特定的优化处理。通过上一篇文章，你已经看到编译器可以对代码进行优化，移除掉不需要的指令，另外，编译器甚至可以移除掉函数的调用，直接把被调用函数的相关代码进行内嵌到调用函数中。</p>

<p>例如，编译器可能会在调用函数中适当的添加add指令，而不是调用addFunction本身。实际上，现如今的编译器已经非常的智能了，针对类似addFunction这样的函数，编译器本身就可以进行加法操作，而不用在代码中添加一条add指令。</p>

<p>本文中，我们不希望编译器对代码进行优化——把代码进行内嵌处理。现在回到工程的main.m文件中，并按照如下方式修改addFunction：</p>

<pre class="wp-code-highlight prettyprint linenums:1">__attribute__((noinline))
int addFunction(int a, int b) {
    int c = a + b;
    return c;
}</pre>


<p>紧接着，在该函数下面添加另外一个函数：</p>

<pre class="wp-code-highlight prettyprint linenums:1">void fooFunction() {
    int add = addFunction(12, 44);
    printf("add = %i", add);
}</pre>


<p>&nbsp;</p>

<p>如上代码所示，fooFunction通过调用addFunction来计算12+44，然后将结果打印出来。这里使用C函数printf进行打印，而没有使用Objective-C的NSLog(NSLog要稍微复杂一点)。</p>

<p>接着再次选择Xcode中的Product\Generate Output\Assembly File，并确保输出设置为Archiving。然后搜索_fooFunction，会看到如下一些内容：</p>

<p><span style="color: #993366;">提醒：在Scheme中一定要选择iOS Device，不要选择模拟器。</span></p>

<pre class="wp-code-highlight prettyprint linenums:1">_fooFunction:
@ 1:
    push    {r7, lr}
@ 2:
    movs    r0, #12
    movs    r1, #34
@ 3:
    mov r7, sp
@ 4:
    bl  _addFunction
@ 5:
    mov r1, r0
@ 6:
    movw    r0, :lower16:(L_.str-(LPC1_0+4))
    movt    r0, :upper16:(L_.str-(LPC1_0+4))
LPC1_0:
    add r0, pc
@ 7:
    blx _printf
@ 8:
    pop {r7, pc}</pre>


<p>上面的代码中，涉及到了一些还没有介绍过的指令，不用担心，它们都不复杂。下面我们就分别来看看上面代码中的指令都做了什么操作：</p>

<p>1、这里的指令作用跟之前介绍的<strong><span style="color: #339966;">add sp, #12</span></strong>类似——r7和lr被“pushed”到栈中，也就是说栈指针(sp)被减去8(因为r7和lr都是4个字节)。需要注意，通过这条指令，栈指针被递减，两个值也被存储到栈中！需要存储r7是因为在这个函数中，该寄存器会被覆盖，而之后又需要还原最初的值；而存储lr寄存器中的值是因为在函数结束时，要使用。</p>

<p><span style="color: #993366;">注意：lr是寄存器(Link Register, LR——R14寄存器)。</span></p>

<p>2、这两个指令属于<strong><span style="color: #339966;">move</span></strong>(mov)指令集中的一个。有时候你会看到movs，而有时候则会看到mov，或者其它类似的名称。它们都是把一个值装载到寄存器中。你可以把数据从一个寄存器“mov”到另外一个寄存器，例如<strong><span style="color: #339966;">mov ro, r1</span></strong>指令，将把r1中的数据装载到r0中，而r1中的数据不会改变。</p>

<p>上面的两行汇编指令中，会将定义在函数中的两个常量装载到r0和r1中。注意，需要将这两个常量装载到r0和r1中，才能够被addFunction正确的使用。</p>

<p>3、 在调用函数的时候，应该将栈指针保存起来，而这里使用r7来保存栈指针(r7是可以用来存储局部变量存储器中的一个)。可能你已经注意到，在该函数中剩下的代码里面并没有再次使用到栈指针或者r7，所以这条指令在这里是多余的——<strong><span style="color: #339966;">有时候，即使开启了编译器的优化，但还是不能做到最佳优化</span></strong>。</p>

<p>4、这条指令(<strong><span style="color: #339966;">bl</span></strong>)对函数进行调用。请记住被调用函数需要的参数已经存储到相关的寄存器中了(r0和r1)。这条指令的执行一般被当做一个分支(branch)。可以理解为<strong><span style="color: #339966;">执行带链接的分支</span></strong>，也就是说，在跳转到分支之前，会将lr(link register)的值设置为当前函数中将要执行的下一条指令，当从分支(被调函数)中返回时，通过lr中的值可以知道当前函数执行到哪里了。</p>

<p>5、当addFunction函数执行完毕，返回后，执行的第一条指令——将addFunction的返回值(存储在r0中)保存起来，以供后续的printf使用。也就是利用<strong><span style="color: #339966;">mov</span></strong>将r0中的值存储到r1中。</p>

<p>6、printf的的第一个参数是一个字符串。这里使用了3条指令将指向字符串首地址的指针装载到r0寄存器中。这个字符串存储在二进制文件的<strong><span style="color: #339966;">数据段“data segment”</span></strong>中，不过该字符串的准确位置在二进制文件被链接之前是不知道的。</p>

<p>字符串其实是在由main.m文件生成的目标文件(object file)中的数据段里。如果你在汇编代码中搜索<strong><span style="color: #339966;">L_.str</span></strong>，就能找到这个字符串。这三个指令中的前两个作用是装载这个常量的地址（减去本地标签加4后的地址）。</p>

<p>第三条指令中将程序计数器(pc)的值加到r0中。因此，现在r0已保存着字符串的地址，也不用考虑L_.str在二进制文件中的确切位置。</p>

<p>下面的这个图演示了内存的布局。其中<strong><span style="color: #339966;">L_.str &#8211; (LPC1_0 + 4)</span></strong>的改变并不用对r0进行改动。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/04-PC-relative-string-480x264.png"><img class="alignnone size-full wp-image-1442" alt="04-PC-relative-string-480x264" src="http://beyondvincent.com/wp-content/uploads/2013/06/04-PC-relative-string-480x264.png" width="480" height="264" /></a></p>

<p>7、这条指令(<strong><span style="color: #339966;">blx</span></strong>)调用printf函数。这跟<span style="color: #339966;"><strong>bl</strong></span>指令有明显的区别。<strong><span style="color: #339966;">blx</span></strong>中的<span style="color: #339966;"><strong>x</strong></span>标示交换“exchange”，意思是如果有必要，处理器将对指令集模式进行切换。</p>

<p>现在的ARM处理器有两种模式：<strong><span style="color: #339966;">ARM</span></strong>和<span style="color: #339966;"><strong>Thumb</strong></span>。Thumb指令是16位的宽度，而ARM指令是32位的宽度。Thumb指令比较少，不过使用Thumb指令意味着代码容量更小，以及更利于CPU缓存。</p>

<p>因此，使用Thumb尺寸得到的好处就是让你的代码更少。这里可以看到更多的Thumb信息：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="https://en.wikipedia.org/wiki/ARM_architecture#Thumb" target="_blank"><span style="color: #339966; text-decoration: underline;">Wikipedia</span></a></span></strong></span>。</p>

<p>8、最后一条指令是将在第一条指令中push到栈里面的值pop出来。这里列出来的寄存器将被从栈中pop出来的值填充，然后栈指针递增。回想一下第一条指令是这样的：r7和lr寄存器中的值被push到栈中，但是为什么这里的指令是将栈中的值pop到r7和pc寄存器中，而不是r7和lr寄存器中呢？</p>

<p>相信你还记得之前说过的：lr寄存器保存的是从一个函数返回时，下一条将被执行指令的地址。所以，如果将push到栈中的这个地址pop给pc(program counter)，那么将继续从函数被调用的地方执行——这也是从一个被调用函数返回调用函数的常规做法，而不是像调用addFunction一样返回到调用函数fooFunction中。</p>

<p>现在我们来看看ARM中的一些指令的简短总结。ARM中又许多指令，不过下面列出来的指令对于初步了解ARM指令非常重要。现在就通过伪代码(pseudo-code)和相关描述来快速的回顾一下这些指令都做有什么作用：</p>

<ul>
<li>mov r0, r1 => r0 = r1</li>
<li>mov r0, #10 => r0 = 10</li>
<li>ldr r0, [sp] => r0 = *sp</li>
<li>str r0, [sp] => *sp = r0</li>
<li>add r0, r1, r2 => r0 = r1 + r2</li>
<li>add r0, r1 => r0 = r0 + r1</li>
<li>push {r0, r1, r2} => 将 r0, r1 和 r2push到栈中.</li>
<li>pop {r0, r1, r2} => 将3个值从栈中pop出来，并存放到r0, r1 和 r2中.</li>
<li>b _label => pc = _label</li>
<li>bl _label => lr = pc + 4; pc = _label</li>
</ul>


<p><strong><span style="color: #ff0000;"> 现在是时候恭喜你了：你能够阅读一些ARM汇编代码了！</span></strong></p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/06-Read-ARM-meme.png"><img class="alignnone size-full wp-image-1446" alt="06-Read-ARM-meme" src="http://beyondvincent.com/wp-content/uploads/2013/06/06-Read-ARM-meme.png" width="552" height="414" /></a></p>

<p><strong style="font-size: 1.5em;"><span style="color: #339966;">Objective -C 汇编</span></strong></p>

<p>到现在为止，我们涉及到的函数都是用C语言来写的。Objective-C在C语言的基础上稍微增加了一点复杂度。下面我们就来看看用Objective-C代码编译出来的汇编指令。打开<strong><span style="color: #339966;">ViewController.m</span></strong>文件，然后将下面的方法添加到类的实现中：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (int)addValue:(int)a toValue:(int)b {
    int c = a + b;
    return c;
}</pre>


<p>同样，通过这样的步骤来查看汇编代码：<strong><span style="color: #339966;">Product\Generate Output\Assembly File</span></strong>。记得将output类型设置为Archiving，然后搜索<strong><span style="color: #339966;">addValue:toValue: </span></strong>，你会发现类似如下的汇编代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">"-[ViewController addValue:toValue:]":
    adds    r0, r3, r2
    bx  lr</pre>


<p>首先看到的是一个<strong><span style="color: #339966;">标签</span></strong>(label)名称——&#8221;&ndash;[ViewController addValue:toValue:]&#8220;，这个名称包含类名和完整的Objective-C方法名称。</p>

<p>把上面的汇编代码与之前的addFunction相关汇编代码进行比较，你会发现这里是将r2和r3进行加法运算，而不是r0与r1相加——这意味着传递给addValue:toValue:方法的参数使用了r2和r3寄存器(没有使用r0和r1)，这是为什么呢？</p>

<p>这是因为：在调用Objective-C方法时，除了传递明确指定的参数外，还会在明确参数之前传递两个隐含的参数(implicit parameter)。addValue:toValue:方法跟下面的C函数是等价的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">int ViewController_addValue_toValue(id self, SEL _cmd, int a, int b) {
    int c = a + b;
    return c;
}</pre>


<p>这就是为什么a和b两个参数分别存储到r2和r3的原因。可能你之前已经听说过前两个参数了(经常使用self吧)。</p>

<p><strong><span style="color: #ff0000;">提醒：self和_cmd占用了r0和r1寄存器。</span></strong></p>

<p>可能之前你还没有见过<strong><span style="color: #339966;">_cmd</span></strong>。其实跟<strong><span style="color: #339966;">self</span></strong>一样，在Objective-C函数中，_cmd是可以直接使用的，它存储着当前执行方法的<strong><span style="color: #339966;">selector</span></strong>。一般来说，你并不需要使用_cmd(这也可能是为什么你从来没有听说过_cmd的原因)。</p>

<p>为了观察Objective-C方法是如何被调用的，现在将如下方法添加到ViewController中：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)foo {
    int add = [self addValue:12 toValue:34];
    NSLog(@"add = %i", add);
}</pre>


<p>重新生成汇编文件，然后寻找<strong><span style="color: #339966;">&#8220;&ndash;[ViewController foo]&#8220;:</span></strong>，应该能看到类似如下的代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">"-[ViewController foo]":
@ 1:
    push    {r7, lr}
@ 2:
    movw    r1, :lower16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))
    movt    r1, :upper16:(L_OBJC_SELECTOR_REFERENCES_-(LPC1_0+4))
LPC1_0:
    add r1, pc
@ 3:
    ldr r1, [r1]
@ 4:
    movs    r2, #12
    movs    r3, #34
@ 5:
    mov r7, sp
@ 6:
    blx _objc_msgSend
@ 7:
    mov r1, r0
@ 8:
    movw    r0, :lower16:(L__unnamed_cfstring_-(LPC1_1+4))
    movt    r0, :upper16:(L__unnamed_cfstring_-(LPC1_1+4))
LPC1_1:
    add r0, pc
@ 9:
    blx _NSLog
@ 10:
    pop {r7, pc}</pre>


<p>同样，这与之前C语言产生的汇编代码非常相似，我们也来看看具体都做了些什么：</p>

<p>1、将r7和lr push到栈中。</p>

<p>2、利用pc(program counter)将标签<strong><span style="color: #339966;">L_OBJC_SELECTOR_REFERENCES_</span></strong>对应的值装载到r1寄存器中。这个标签引用到一个selector。实际上selector就是一个字符串，并且存储在数据段中(data segment)。</p>

<p>3、如果在汇编文件中搜索L_OBJC_SELECTOR_REFERENCES_，会看到如下内容：</p>

<pre class="wp-code-highlight prettyprint linenums:1"> L_OBJC_SELECTOR_REFERENCES_:     .long   L_OBJC_METH_VAR_NAME_</pre>


<p>r1会指向这里(<strong><span style="color: #339966;">L_OBJC_SELECTOR_REFERENCES_</span></strong>)，这个标签包含了另外一个标签：<strong><span style="color: #339966;">L_OBJC_METH_VAR_NAME_</span></strong>。在文件中查找这个标签(<strong><span style="color: #339966;">L_OBJC_METH_VAR_NAME_</span></strong>)，会找到这样的字符串：addValue:toValue:。</p>

<p>而指令<strong><span style="color: #339966;">ldr r1, [r1]</span></strong>的作用：对r1中存储的地址进行解引用(dereferencing)，然后将得到的值放到r1中。如果用C伪代码看起来应该是这样的：r1 = *r1。仔细想想的话，可能你应该知道r1将会存储着指向字符串addValue:toValue: 的指针。</p>

<p>4、将常量装载到r2和r3中。</p>

<p>5、 将sp保持到r7寄存器中。</p>

<p>6、这是一个分支(branch)，<strong><span style="color: #339966;">以带链接跳转和根据情况切换指令集的模式</span></strong>来调用objc_msgSend方法。这是Objective-C runtime中非常重要的一个方法——它根据传递的参数找到并调用相关的函数。</p>

<p>该方法使用到了4个参数(r0-r3)。因此，在上面的代码中，将selector装载到r1中，另外两个参数(12和34)装载到r2和r3中。<strong><span style="color: #339966;">注意：在此并没有明确的装载r0，因为r0已经存储着self变量了。</span></strong></p>

<p>7、调用addValue:toValue:的返回值被存放在r0中。这里的指令将这个结果值保持到r1中。在接下来调用NSLog函数时会用到这个值。</p>

<p>8、将NSLog用到的第一个字符串参数装载到r0中。这跟之前介绍的用C函数里面调用printf一样。</p>

<p>9、这是一个分支(branch)，<strong>以<span style="color: #339966;">带链接跳转和根据情况切换指令集的模式</span></strong>来调用NSLog方法。</p>

<p>10、从栈中pop出两个值，并放入r7和pc寄存器中。这跟之前一样，从foo方法中返回。</p>

<p>如上所见，由C和Objective-C代码生成汇编指令，区别不是太大。只不过在Objective-C生成的汇编指令中，会隐示的给方法传递两个参数，以及使用到的selector以字符串的形式存放在数据段中(data segment)。</p>

<h2><strong><span style="color: #339966;">Obj-C 消息发给了谁</span></strong></h2>

<p>上面我们看到了<strong><span style="color: #339966;">objc_msgSend</span></strong>方法。可能你在crash log中已经看到过这个方法。该方法是Objective-C runtime中的一个核心方法。runtime包含了内存管理以及类的相关处理。</p>

<p>每次调用Objective-C方法时，都由objc_msgSend方法(这是一个C方法)处理消息的派送(dispatching)。该方法根据传递的消息类型在类的方法列表中查找被调用方法的实现。objc_msgSend方法的签名(signature)看起来是这样的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">id objc_msgSend(id self, SEL _cmd, ...)</pre>


<p>在方法执行期间，第一个参数是self。在方法中写的一些代码，例如self.someProperty，其中self就是来自自objc_msgSend方法中的self参数。</p>

<p>第二个参数很少人会知道，这也是一个被隐藏的参数(hidden parameter)。如果在Objective-C方法中，写这类似这样的代码：<strong><span style="color: #339966;">NSLog(@&#8221;%@&#8221;, NSStringFromSelector(_cmd));</span></strong> ，会看到控制台输出了当前的selector。</p>

<p>剩下的参数一般就是开发者传递给该方法的参数了。所以如果一个方法携带两个参数，例如上面的<strong><span style="color: #339966;">addValue:toValue:</span></strong>，那么还会携带额外的两个参数。因此，我们也可以用下面的代码来代替通过Objective-C方式的调用：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (void)foo {
    int add = (int)objc_msgSend(self, NSSelectorFromString(@"addValue:toValue:", 12, 34);
    NSLog(@"add = %i", add);
}</pre>


<p><span style="color: #993366;">注意：虽然objc_msgSend的返回值类型是id，不过在上面的代码中将其转换为int类型了。因为它们 的size是相同的，所以转换为int不会有问题。如果该方法返回的是不同的size，那么实际上是别的函数被调用了，更多内容请看这里：<span style="text-decoration: underline; color: #339966;"><strong><a href="http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html"><span style="color: #339966; text-decoration: underline;">here</span></a></strong></span>。同样，如果返回的是一个floating指针，那么则是objc_msgSend的另一个变种被调用了，更多内容请看这里：<span style="text-decoration: underline; color: #339966;"><strong><a href="http://sealiesoftware.com/blog/archive/2008/11/16/objc_explain_objc_msgSend_fpret.html" target="_blank"><span style="color: #339966; text-decoration: underline;">here</span></a></strong></span>。</span></p>

<p>当一个Objective-C方法被编译的时候，上面用C写的等效方法签名应该是这样的：</p>

<pre class="wp-code-highlight prettyprint linenums:1">int ViewController_addValue_toValue(id self, SEL _cmd, int a, int b)</pre>


<p>对此为什么会这样，现在应该不会感觉到奇怪——这样的签名是为了与objc_msgSend相匹配！也就是说当objc_msgSend在查找并跳转到对应方法时，所有的这些参数都应该在正确的地方。</p>

<p>这里可以看到更多关于objc_msgSend相关内容：<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://www.mikeash.com/pyblog/friday-qa-2012-11-16-lets-build-objc_msgsend.html" target="_blank"><span style="color: #339966; text-decoration: underline;">文章1</span></a></span></strong></span>，<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://sealiesoftware.com/blog/archive/2008/09/22/objc_explain_So_you_crashed_in_objc_msgSend.html" target="_blank"><span style="color: #339966; text-decoration: underline;">文章2</span></a></span></span></strong>。</p>

<h2><strong><span style="color: #339966;">你现在可以进行逆向工程了</span></strong></h2>

<p>根据上面对ARM汇编的介绍，你应该可以能够知道为什么有些代码被breaking、crashing或者没有正确的执行。</p>

<p>通过观察相关的汇编代码，可以更加清楚的获知到引起bug的详细步骤。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/interrogation.png"><img class="alignnone size-full wp-image-1465" alt="interrogation" src="http://beyondvincent.com/wp-content/uploads/2013/06/interrogation.png" width="651" height="241" /></a></p>

<p>有时候，你可能无法查看源代码——例如，你遇到的bug是发生在第三方库或者系统的framework中。此时，通过汇编指令进行分析可以帮助你迅速的找到问题。下面的目录存放着iOS SDK中所有的framework：</p>

<p>&lt;Path_to_Xcode>/Contents/Developer/Platforms/iPhoneOS.platform/Developer/ SDKs/iPhoneOS6.1.sdk/System/Library/Frameworks</p>

<p>我建议使用<strong><span style="color: #339966;"><a href="http://www.hopperapp.com/" target="_blank"><span style="color: #339966;">HopperApp</span></a></span></strong>对这些库进行分析。该软件能够对二进制文件进行反汇编——这样你就可以看库中的内容了——这样做是没有问题的！！！例如，打开UIKit，就可以看到每个方法都做了什么。如下图所示：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/05-HopperApp-1.png"><img class="alignnone size-full wp-image-1466" alt="05-HopperApp-1" src="http://beyondvincent.com/wp-content/uploads/2013/06/05-HopperApp-1.png" width="1015" height="231" /></a></p>

<p>上图中的汇编代码是<strong><span style="color: #339966;">[UINavigationController shouldAutorotateToInterfaceOrientation] </span></strong>方法相关的。结合之前介绍的ARM汇编知识，相信上面的汇编代码具体做了些什么你应该能看出来。</p>

<p>首先是将一个selector引用装载到ri寄存器中，以供后续调用objc_msgSend使用。然后可以看到，别的寄存器并没有做任何改动，所以我们可以知道传递给objc_msgSend方法的self指针(存储在r0中)，跟传递给<strong><span style="color: #339966;">shouldAutorotateToInterfaceOrientation</span></strong>方法的self是同一个。</p>

<p>同理，我们可以知道被调用方法携带一个参数(代码中有一列是用来显示相关名称的)。由于r2寄存器没有改动过，所以这个参数就是从shouldAutorotateToInterfaceOrientation方法传入的。</p>

<p>最后，函数调用之后，r0没有改动过，所以被调用函数的返回值就是调用函数的返回值。</p>

<p>这样一来，就可以推断出这个方法的实现应该是这样的了：</p>

<pre class="wp-code-highlight prettyprint linenums:1">- (BOOL)shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation)interfaceOrientation {
    return [self _doesTopViewControllerSupportInterfaceOrientation:interfaceOrientation];
}</pre>


<p>cool！很容易吧！虽然大多数方法都比上面的这个要复杂，不过你可以根据汇编指令拼凑出一些代码，进而快速的确定这些代码做了些什么。</p>

<p><strong style="font-size: 1.5em;"><span style="color: #339966;">何去何从</span></strong></p>

<p>这篇关于iOS汇编的教程向你介绍了一些运行在iOS设备中的ARM汇编指令核心概念。你应该学习到了C和Objective-C相关的一些调用约定。</p>

<p>通过本文介绍的知识，当你的程序在使用系统库crash时，你可以对所有能看到的随机代码进行分析。当然，你也可以通过汇编指令来准确的分析你自己写的方法。</p>

<p>如果你希望更加深入的了解ARM，请看这里：<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.raspberrypi.org/"><span style="color: #339966; text-decoration: underline;">Raspberry Pi</span></a></span></span></strong>。这里的涉及到的小型设备都拥有ARM处理器，跟iOS设备非常相似，同时也有许多教程可以教你如何对这些设备进行编程。</p>

<p>另外，NEON也值得去学习了解。这是另外扩展的一套指令集，自iPhone 3GS以来设备中的所有处理器，都支持NEON指令集。该指令集提供了SIMD(单指令，多数据——Single Instruction Multiple Data)指令，对数据的处理非常高效，例如，图片的处理。如果你需要对数据进行高效的处理，那么最好学习一下如何直接写NEON指令，并结合使用内联汇编(inline assembly)。这个指令集非常的先进！</p>

<p>这应该够你忙乎一阵了:]。</p>

<div style="text-align: left;">
  <span style="color: #808080;">本文由<span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-20</time></span>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS汇编教程：ARM(1)]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/06/19/90/"/>
    <updated>2013-06-19T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/06/19/90</id>
    <content type="html"><![CDATA[<p>注：本文由破船译自：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://www.raywenderlich.com/37181/ios-assembly-tutorial" target="_blank"><span style="color: #339966; text-decoration: underline;">raywenderlich</span></a></span></strong></span><br/>
感谢<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://blog.devtang.com/" target="_blank"><span style="color: #339966; text-decoration: underline;">唐巧</span></a></span></strong></span>抽出时间对本文进行double-check。</p>

<div id="attachment_1399" class="wp-caption alignright" style="width: 264px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssemblySmall.png"><img class="wp-image-1399 " alt="SpeakAssemblySmall" src="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssemblySmall.png" width="254" height="254" /></a><p class="wp-caption-text">
    你说的是汇编吗？
  </p>
</div>


<p>我们写的Objective-C代码，最终会被转换为机器代码 —— 由ARM处理器能识别的1和0组成。实际上，在机器代码之间，还有一门人类可以阅读的语言 —— 汇编语言。</p>

<p>了解汇编，可以深入到你的代码里面进行调试和优化的探索，并有助于你对Objective-C运行时(runtime)的理解，同时也能满足你内心的好奇！</p>

<p>在这篇iOS汇编教程中，你能学到：</p>

<ul>
<li><strong><span style="color: #339966;">什么是汇编</span></strong> —— 以及为什么需要关注它。</li>
<li><strong><span style="color: #339966;">如何阅读汇编</span></strong> —— 特别是由Objective -C生成的汇编。</li>
<li><strong><span style="color: #339966;">在调试的时候如何使用assembly view</span></strong> —— 遇到一个bug或者crash，看看到底是怎么回事，这非常有用。</li>
</ul>


<p>为了有效吸收本文内容，建议本文的读者对象为已经熟悉Objective-C编程了。当然，你也应该要知道一些简单的计算机科学相关概念，例如栈、CPU以及它们是如何运行的。如果你对CPU不太熟悉，建议在阅读本文之前，先看看这里的内容：<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://www.howstuffworks.com/microprocessor.htm" target="_blank"><span style="color: #339966; text-decoration: underline;">微处理器的工作原理</span></a></span></span></strong>。</p>

<p>目录[分两篇文章翻译]：</p>

<h2><strong><span style="color: #339966;">iOS汇编教程：ARM(1)</span></strong></h2>

<ul>
<li><strong><span style="color: #339966;">开始：什么是汇编</span></strong></li>
<li><strong><span style="color: #339966;">函数调用约定</span></strong></li>
<li><strong><span style="color: #339966;">创建工程</span></strong></li>
<li><strong><span style="color: #339966;">加法(addFunction)</span></strong></li>
</ul>


<h2><span style="text-decoration: underline;"><a href="http://beyondvincent.com/?p=1434" target="_blank"><strong><span style="color: #339966; text-decoration: underline;">iOS汇编教程：ARM(2)</span></strong></a></span></h2>

<ul>
<li><strong><span style="color: #339966;">函数的调用</span></strong></li>
<li><strong><span style="color: #339966;">Objective -C 汇编</span></strong></li>
<li><strong><span style="color: #339966;">Obj-C 消息发给了谁</span></strong></li>
<li><strong><span style="color: #339966;">你现在可以进行逆向工程了</span></strong></li>
<li><strong><span style="color: #339966;">何去何从</span></strong></li>
</ul>


<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&ndash;</p>

<h1><span style="color: #339966;"><strong>iOS汇编教程：ARM(1)</strong></span></h1>

<h2><strong><span style="color: #339966;">开始：什么是汇编</span></strong></h2>

<p>Objective-C是一门高级语言。编译器会将你的Objective-C代码编译为汇编语言代码：一门低级语言，不过还不是最低级的语言。</p>

<p>这些汇编会被汇编器(assembler)组装为机器代码——CPU可以识别的0和1。好在一般开发者并没有必要考虑机器代码，不过有时候详细的了解汇编，会非常有用。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssembly.png"><img class="alignnone size-full wp-image-1403" alt="SpeakAssembly" src="http://beyondvincent.com/wp-content/uploads/2013/06/SpeakAssembly.png" width="651" height="241" /></a></p>

<p>每一个汇编指令都会告诉CPU执行一个相关任务，例如“对两个数字执行加(add)操作”，或“从某个内存地址加载数据”。</p>

<p>除了主存外 ——如 iPhone 5有1GB的主存、Mac电脑可能会有8GB —— CPU还有少许的存储部件，称之为<strong><span style="color: #339966;">寄存器</span></strong>，寄存器的访问速度非常快，一个寄存器就像一个变量一样，可以存储单个值。</p>

<p>所有的iOS设备(实际上，现如今，几乎所有的移动设备)使用的CPU都是基于<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/ARM_architecture" target="_blank"><span style="color: #339966; text-decoration: underline;">ARM架构</span></a></span></strong></span>。 ARM芯片使用的指令集是<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/Reduced_instruction_set_computing" target="_blank"><span style="color: #339966; text-decoration: underline;">RISC</span></a></span></span></strong>(精简指令集)，该指令集非常的精简，并且易读（比<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/X86" target="_blank"><span style="color: #339966; text-decoration: underline;">x86</span></a></span></span></strong>的指令集精简多了）。</p>

<p>一个汇编指令(或者语句)看起来如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">mov r0, #42</pre>


<p>上面的这行汇编指令，涉及到好多命令(或操作)。mov的作用是对数据进行移动。在ARM汇编指令中，目标是第一个，所以，上面的指令是将值42移动到寄存器r0中。再来看看下面的代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">ldr   r2, [r0]
ldr r3, [r1]
add r4, r2, r3</pre>


<p>上面汇编指令的作用是首先将寄存器r0和r1中的值装载到寄存器r2和r3中，然后对寄存器r2和r3中的值进行加(add)操作，加的结果存放到r4中。</p>

<p>很容易看懂吧！</p>

<h2><strong><span style="color: #339966;">函数调用约定</span></strong></h2>

<p>要想理解汇编代码，首先重要的事情就是理解代码之间的交互——意思是一个函数调用另一个函数的方式。这包括了参数如何传递以及如何从函数返回结果——称之为调用的约定。编译器必须严格的遵守相关标准进行代码编译，这样生成的代码，才能够相互兼容。</p>

<p>上面讨论过，寄存器是的存储空间非常少，并且靠近CPU——用来存储当前使用的一些值。ARM CPU有16个寄存器：r0到r15。每个寄存器为32bit。调用约定规定了这些寄存器的特定用途。如下：</p>

<ul>
<li> r0 &#8211; r3：存储传递给函数的参数值。</li>
<li> r4 &#8211; r11：存储函数的局部变量。</li>
<li>r12：是内部过程调用暂时寄存器（intra-procedure-call scratch register）。</li>
<li>r13：存储栈指针(sp)。在计算机中，栈非常重要。这个寄存器保存着栈顶的指针。这里可以看到更多关于栈的信息：<span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://en.wikipedia.org/wiki/Call_stack"><span style="color: #339966; text-decoration: underline;">Wikipedia</span></a></span></strong></span>。</li>
<li>r14：链接寄存器(link register)。存储着当被调用函数返回时，将要执行的下一条指令的地址。</li>
<li>r15：用作程序计数器(program counter)。存储着当前执行指令的地址。每条执行被执行后，该计数器会进行自增(+1)。</li>
</ul>


<p>这里可以看到更多相关ARM 调用约定的内容：<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf"><span style="color: #339966; text-decoration: underline;">this document from ARM</span></a></span></span></strong>。苹果公司也给出了一份文档详细介绍了在iOS开发中的调用约定： <span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/iPhoneOSABIReference.pdf"><span style="color: #339966; text-decoration: underline;">calling convention used for iOS development</span></a></span></span>。</p>

<p>下面我们就从代码上开始真正的认识汇编。</p>

<h2><strong><span style="color: #339966;">创建工程</span></strong></h2>

<p>打开Xcode，<strong><span style="color: #339966;">File\New\New Project</span></strong>，选择<strong><span style="color: #339966;">iOS\Application\Single View Application</span></strong>，然后点击<strong><span style="color: #339966;">Next</span></strong>，工程的配置如下：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/01-Create-the-project.png"><img class="alignnone size-full wp-image-1416" alt="01-Create-the-project" src="http://beyondvincent.com/wp-content/uploads/2013/06/01-Create-the-project.png" width="1394" height="841" /></a></p>

<ul>
<li><strong><span style="color: #339966;">Product name</span></strong>: ARMAssembly</li>
<li><strong><span style="color: #339966;">Company Identifier</span></strong>: 一般为反向的DNS标示</li>
<li><strong><span style="color: #339966;">Class Prefix</span></strong>: 空白</li>
<li><strong><span style="color: #339966;">Devices</span></strong>: iPhone</li>
<li><strong><span style="color: #339966;">Use Storyboards</span></strong>: No</li>
<li><strong><span style="color: #339966;">Use Automatic Reference Counting</span></strong>: Yes</li>
<li><strong><span style="color: #339966;">Include Unit Tests</span></strong>: No</li>
</ul>


<p>点击 Next 选择工程存储的位置——完成工程的创建。</p>

<h2><span style="color: #339966;">加法(addFunction)</span></h2>

<p>下面我们写一个加法函数：对两个数进行相加，然后返回结果。这里我们先用C语法写，后面再介绍用OC来写（OC稍微复杂一点）。在工程的Supporting Files目录中打开<strong><span style="color: #339966;">main.m</span></strong>文件，然后将下面的函数拷贝并粘贴到文件的顶部。</p>

<pre class="wp-code-highlight prettyprint linenums:1">int addFunction(int a, int b) {
    int c = a + b;
    return c;
}</pre>


<p>现在将Xcode中的scheme设置为为设备构建:选中iOS Device作为scheme target(如果你将设备连接到电脑中，会现实&lt;你的设备名称>，如“Matt Galloway的iPhone 5”)——这样选择之后，生成的汇编就是针对ARM的，而不是针对x86(模拟器使用)。Xcode的选择效果如下图所示：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/02-Select-iOS-Device-scheme.png"><img class="alignnone size-full wp-image-1420" alt="02-Select-iOS-Device-scheme" src="http://beyondvincent.com/wp-content/uploads/2013/06/02-Select-iOS-Device-scheme.png" width="291" height="49" /></a></p>

<p>&nbsp;</p>

<p>然后选择:<strong><span style="color: #339966;">Product\Generate Output\Assembly File</span></strong>。过一会之后，Xcode会生成一个文件，这个文件里面有很多行都有下划线__。在文件的顶部,好多行都是以<strong><span style="color: #339966;">.section</span></strong>开头。接着选中<strong><span style="color: #339966;">Show Assembly Output For</span></strong>中的<strong><span style="color: #339966;">Running</span></strong>。</p>

<p><span style="color: #993300;">  注意:默认情况下,使用的是debug scheme中的设置信息,所以默认选中的就是Running。在debug模式下，编译器对代码没有做优化处理——首先观察没有进过优化处理的汇编，更利于理解代码具体都发生了什么。</span></p>

<p>在生成的文件中搜索_addFunction,会看到类似如下的代码:</p>

<pre class="wp-code-highlight prettyprint linenums:1">.globl    _addFunction
    .align  2
    .code   16                      @ @addFunction
    .thumb_func _addFunction
_addFunction:
    .cfi_startproc
Lfunc_begin0:
    .loc    1 13 0                  @ main.m:13:0
@ BB#0:
    sub sp, #12
    str r0, [sp, #8]
    str r1, [sp, #4]
    .loc    1 14 18 prologue_end    @ main.m:14:18
Ltmp0:
    ldr r0, [sp, #8]
    ldr r1, [sp, #4]
    add r0, r1
    str r0, [sp]
    .loc    1 15 5                  @ main.m:15:5
    ldr r0, [sp]
    add sp, #12
    bx  lr
Ltmp1:
Lfunc_end0:
    .cfi_endproc</pre>


<p>上面的代码看起来有点凌乱,实际上也不难以读懂。我们来看看，首先，所有以&#8221;.&#8221;开头的代码行都不是汇编指令,我们可以忽略所有这些以&#8221;.&#8221;开头的代码行。</p>

<p>代码中以冒号结尾的的代码行(例如<strong><span style="color: #339966;">_addFunction</span></strong>:和<strong><span style="color: #339966;">Ltim0</span></strong>: )，我们称之为标签（<strong><span style="color: #339966;">label</span></strong>）。这些标签的作用是给汇编代码片段指定相关的名字.名为<strong><span style="color: #339966;">_addFunction</span></strong>:的标签,实际上是一个函数的入口点.</p>

<p>这个标签(<span style="color: #339966;"><strong>_addFunction</strong></span>: )是必须有的:别的代码调用addFunction函数时,并不需要知道该函数具体在什么地方,通过简单的一个符号或标签就可以进行调用.在最终生成程序二进制文件时,链接器会把这个标签转换到实际的地址.</p>

<p>我们需要注意的时,编译器总是会在函数名前面添加一个下划线——这仅仅是一个约定。另外，其他所有的标签都是以<strong><span style="color: #339966;">L</span></strong>开头——这些通常称为局部标签(local label)，只会在函数内部使用。在上面的代码中，虽然没有实际用到局部标签，不过编译器还是为我们生成了一些——之所以会生成这些没有被使用到的局部标签，是由于代码还没有做任何的优化处理。</p>

<p>注释是以<strong><span style="color: #339966;">@</span></strong>字符开头。通过上面的分析,这样一来，忽略掉注释和标签，代码看起来如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">_addFunction:
@ 1:
    sub sp, #12
@ 2:
    str r0, [sp, #8]
    str r1, [sp, #4]
@ 3:
    ldr r0, [sp, #8]
    ldr r1, [sp, #4]
@ 4:
    add r0, r1
@ 5:
    str r0, [sp]
    ldr r0, [sp]
@ 6:
    add sp, #12
@ 7:
    bx  lr</pre>


<p>下面我们来看看代码中每部分汇编都做了什么:</p>

<p>1、首先，在栈(stack)创建临时存储所需要的空间。栈提供了许多内存供函数使用。ARM中的栈是向下延伸的,也就是说,在栈上创建一些空间,需要从栈指针开始减去(subtract)一些空间。在这里，预留了12个字节。</p>

<p>2、r0和r1用来存储传递给调用函数的参数值。如果函数有4个参数，那么会把r2和r3当做第三个和第四个参数。如果函数的参数超过了4个，或者携带的参数不适合使用32位的寄存器（例如很大的数据结构），那么可以通过栈来传递这些参数。</p>

<p>在这里,两个参数被保存到栈中。这是由存储寄存器(str)指令完成的。</p>

<p>上面的指令可以指定一个偏移量,用来应用在某个值上面。所以[sp, #8]的意思是存储至“栈指针寄存器+8的地方”,因此,str r0, [sp, #8]的作用是：将寄存器r0中的内容存储到栈指针(加8)指向的内存地址.</p>

<p>3、将刚刚保存到栈中的值读取至相同的寄存器中(r0和r1)。这里，的ldr指令与str指令刚好相反，ldr(load register)会把指定内存位置中的的内容加载到寄存器中。ldr和str的语法非常相似：ldr r0, [sp, #8]的作用是“将栈指针加8后指向的地址内容加载到r0寄存器中”。</p>

<p>这里你可能会感觉到奇怪,为什么ro和r1寄存器中的值刚刚保存,马上又将其加载回来,答案是:这两行代码是冗余的,可以去掉!如果编译器做了优化处理,那么这些冗余的代码会被忽略掉.</p>

<p>4、这是该函数中最终的要一个指令:执行加操作。该执行的意思是：将r0和r1中的内容进行相加，然后把结果放到r0中。</p>

<p>add指令可以是两个参数,也可以是三个参数.如果指定三个参数,那么第一个参数就被当做目标寄存器,剩下的两个则为源寄存器.因此,这里的指令可以写成这样:add r0, r0, r1。</p>

<p>5、同样，编译器生成了一些冗余代码：将加的结果存储到栈中，接着立即从栈中读取回来。</p>

<p>6、终止函数的地方：将栈指针指向调用addFunction函数时的最初地方。addFunction开始于：sp减去12的地方：预留了12个字节。现在将12加回去即可。这里必须确保栈指针的正确操作，否则栈指针会指向错误的地方。</p>

<p>最后,执行bx指令会回到调用函数的地方.这里的寄存器lr是链接寄存器(link register)，该存储器存储着将要执行的下一条指令。注意,addFunction返回之后,r0寄存器会存储着该函数相加的结果值——这也是调用约定中的一部分：函数的返回值永远都被存储在r0寄存器中。除非一个寄存器不够存储，这是可以使用r1-r3。</p>

<p>上面就是所有相关addFunction的介绍,并不复杂吧?预知关于这些指令的更多内容,请看这里: <span style="text-decoration: underline;"><strong><span style="color: #339966; text-decoration: underline;"><a href="http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001l/QRC0001_UAL.pdf"><span style="color: #339966; text-decoration: underline;">ARM website</span></a></span></strong></span>.</p>

<p>重申一下,上面的方法有好多冗余的地方:这是由于编译器处于debug模式,不会对代码做优化处理.如果对代码进行了优化处理,会看到生成的汇编代码非常的少。</p>

<p>选中<strong><span style="color: #339966;">Show Assembly Output For</span></strong>中的<strong><span style="color: #339966;">Archiving</span></strong>。然后搜索_addFunction:，会看到如下指令（只有这些）：</p>

<pre class="wp-code-highlight prettyprint linenums:1">_addFunction:
    add r0, r1
    bx  lr</pre>


<p>这看起来非常简洁:只需要两条指令就完成了addFunction函数的功能。当然，在实际开发中，一个函数一般都会有好多指令。</p>

<p>现在,这个addFunction已经返回到调用的函数那里了.下面我们就来看看关于调用的函数的相关信息.</p>

<p>下面的内容会在第二篇文章中翻译：</p>

<h1><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/?p=1434" target="_blank"><span style="color: #339966; text-decoration: underline;"><strong>iOS汇编教程：ARM(2)</strong></span></a></span></span></h1>

<ul>
<li><span style="color: #339966;"><strong>函数的调用</strong></span></li>
<li><span style="color: #339966;"><strong>Objective &#8211; C 汇编</strong></span></li>
<li><span style="color: #339966;"><strong>Obj-C 消息发给了谁</strong></span></li>
<li><span style="color: #339966;"><strong>你现在可以进行逆向工程了</strong></span></li>
<li><span style="color: #339966;"><strong>何去何从</strong></span></li>
</ul>


<div style="text-align: left;">
  <span style="color: #808080;">本文由<span style="text-decoration: underline; color: #339966;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-19</time></span>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[父爱天天有]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/06/17/89/"/>
    <updated>2013-06-17T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/06/17/89</id>
    <content type="html"><![CDATA[<p>2013年6月16日是父亲节，祝愿天下的父亲们都身体都健康！</p>

<p><strong><span style="color: #339966;">注1</span></strong>：首先感谢<span style="text-decoration: underline;"><a href="http://www.weibo.com/lancy1014" target="_blank"><span style="color: #339966; text-decoration: underline;">@晨钰Lancy</span></a></span>对我昨天文章<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a title="固定链接到 iOS7新特征汇总[05]初窥UIKit动力(UIKit Dynamics)" href="http://beyondvincent.com/2013/06/16/ios7%e6%96%b0%e7%89%b9%e5%be%81%e6%b1%87%e6%80%bb05%e5%88%9d%e7%aa%a5uikit%e5%8a%a8%e5%8a%9buikit-dynamics/" rel="bookmark"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总[05]初窥UIKit动力(UIKit Dynamics)</span></a></span></span>中的一个错误进行提醒：UIKit Dynamics中UIGravityBehavior的重力单位应该是UIKit Gravity。我已经对博文和相关代码进行了修改。另外，由于笔者才学疏浅，如果大家在看我博文的时候遇到不对的地方，请狠批我，我已经做好准备迎接大家手里的板砖、鸡蛋和手机啦。</p>

<p><strong><span style="color: #339966;">注2</span></strong>：最近几天连续的学习iOS7新东西（白天上班，晚上基本都是在看WWDC和iOS7相关的内容），一者会有点累，再者感觉对新知识点消化吸收效率不是太高，在写博文的时候，会容易出错，误导大家——为了身体能够健康的生产（身体是父母给的，至少要让父母少担心），文章能够准确的输出，在后面的文章中，不能确保一天出一篇，在时间和精力允许的情况下，我尽量！另外，大家也可以跟我反馈感兴趣的topic，我会优先考虑。</p>

<p><strong><span style="color: #339966;">注3</span></strong>：今天不会有新的技术与大家分享！大家如果对我的博文感兴趣，可以收藏我的博客站点：<span style="text-decoration: underline;"><a href="http://BeyondVincent.com" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://BeyondVincent.com">http://BeyondVincent.com</a></span></a></span>。也可以关注我的微博：<span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://www.weibo.com/beyondvincent" target="_blank"><span style="color: #339966; text-decoration: underline;">@BeyondVincent</span></a></span></span>。</p>

<h2><span style="color: #339966;">今天的正文</span></h2>

<p>2013年6月16日是父亲节。好久没有跟父亲联络了，还记得上一次联络是2周前父亲跟我打电话，我与父亲联络比较少，基本都是跟母亲联络。</p>

<p>还记得，刚毕业那会，从云南去北方(大连)工作的时候，父亲经常跟我说有空要去大连游玩一下，结果直到离开大连的时候，也没有完成父亲的这个小心愿，后来，在北京呆了一段时间，也希望有时间带上父亲，去首都转转，结果还是没能如愿。再后来，父亲没有再提游玩的事情。现如今，我人已回云南，想想父亲辛劳了好多年，自己却很难孝敬，心里时常会感觉内疚。现在唯一能孝敬父亲，并让父亲安心的就是做到让自己身体健康。也希望，尽快完成父亲的小心愿。</p>

<p>与父亲一起合影的次数并不太多，而单独与父亲合影，只有下面这张！</p>

<h1><span style="color: #339966;">在这里祝愿我的父亲身体健康！</span></h1>

<h1><span style="color: #339966;">也祝愿天下所有人的父亲身体健康！</span></h1>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/%E7%88%B6%E5%AD%90.jpg"><img class="alignnone size-full wp-image-1389" alt="父子" src="http://beyondvincent.com/wp-content/uploads/2013/06/父子.jpg" width="670" height="502" /></a></p>

<div>
  本文由<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-17</time>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7新特征汇总[05]初窥UIKit动力(UIKit Dynamics)]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/06/16/88/"/>
    <updated>2013-06-16T00:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/06/16/88</id>
    <content type="html"><![CDATA[<p>提醒：这里是新特征汇总博文链接：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://beyondvincent.com/2013/06/11/ios7%E6%96%B0%E7%89%B9%E5%BE%81%E6%B1%87%E6%80%BB/" target="_blank"><span style="color: #339966; text-decoration: underline;">iOS7新特征汇总</span></a></strong></span></span></p>

<div id="attachment_1359" class="wp-caption alignnone" style="width: 1141px">
  <a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130615-6.png"><img class="size-full wp-image-1359" alt="QQ20130615-6" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130615-6.png" width="1131" height="564" /></a><p class="wp-caption-text">
    此图来此WWDC视频
  </p>
</div>


<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>通过之前的4篇文章，笔者把iOS7中的涉及到的一些新特征做了一个简单的介绍。本文将带领大家初窥新特征里面的一个topic：UIKit动力(<span style="color: #339966;">UIKit Dynamics</span>)。</p>

<p><strong><span style="color: #339966;">注1</span></strong>：关于UIKit Dynamics的中文名称：我在这里叫做UIKit动力，也有人叫UIKit动力模型和UIKit动态，总感觉怪怪的——所以大家在看到的时候不要在意即可。<br/>
<strong><span style="color: #339966;">注2</span></strong>：今天有开发者提起iOS7 beta还处于苹果的<span style="color: #339966;">NDA</span>(Non-Disclosure Agreement)状态，也就是说目前关于iOS7 beta的任何内容除了官方公开发表的信息外，作为开发者最多只能在苹果的开发者论坛上进行讨论交流，禁止在公开场合谈论关于iOS7 beta的信息。关于NDA感觉国外的意识比较好，就跟版权意识一样。由此笔者也在这里友情提醒一下：读者单纯的看本系列文章即可，在iOS7 release之前，<span style="color: #339966;">保持沉默状态</span>。<br/>
<strong><span style="color: #339966;">注3</span></strong>：本文在写作的时候参考了如下一些内容(具体内容请登录苹果开发者网站查阅)：</p>

<ol>
<li>WWDC 2013 session 206 — Getting Started with UIKit Dynamics</li>
<li>UIDynamicAnimator Class Reference</li>
<li>UIDynamicAnimatorDelegate Protocol Reference</li>
<li>UIDynamicBehavior Class Reference</li>
<li>UIDynamicItem Protocol Reference</li>
<li>UIDynamicItemBehavior Class Reference</li>
<li>UIKit Dynamics Catalog(Sample Code)</li>
</ol>


<h2><strong><span style="color: #339966;">UIKit动力简介</span></strong></h2>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130615-5.png"><img alt="QQ20130615-5" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130615-5.png" width="1101" height="338" /></a></p>

<p><img class=" wp-image-1360 alignright" alt="code" src="http://beyondvincent.com/wp-content/uploads/2013/06/code.png" width="115" height="115" /></p>

<p>什么是UIKit动力？—— 一句话：<span style="color: #339966;">UIKit动力提供了一个模拟真实世界中力学相关的动画和交互系统</span>。比如重力、碰撞和吸附等。UIKit动力具有可组合、可重用和声明式的特点。</p>

<p>在程序中利用UIKit提供的接口来实现力学行为，可以减少80%的代码量。</p>

<p>&nbsp;</p>

<h2><span style="color: #339966;"><strong>UIKit动力架构</strong></span></h2>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130616-8.png"><img class="alignnone size-full wp-image-1363" alt="QQ20130616-8" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130616-8.png" width="1031" height="459" /></a></p>

<p>如上图所示，UIKit动力系统中，涉及到如下4个内容：<span style="color: #339966;"><br /> </span></p>

<div title="Page 49">
  <img class=" wp-image-1365 alignright" alt="QQ20130616-9" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130616-9.png" width="240" height="165" /><span style="color: #339966;">UIDynamicAnimator：<span style="color: #333333;">UIDynamicAnimator介于iOS图形引擎和动力项(View)之间，</span></span><span style="color: #339966;"><span style="color: #333333;">具有如下功效</span>：<br /> </span></p> <ul>
    <li>
      提供动力行为的上下文
    </li>
    <li>
      根据ref view确定坐标系
    </li>
    <li>
      控制动力引擎
    </li>
    <li>
      维护着动力行为的状态
    </li>
  </ul>
  
  <p>
    UIDynamicAnimatorDelegate是与UIDynamicAnimator相关的一个delegate。主要用于动力行为被启动或者暂定时，做出的回应。也就是说，在动力行为运行期间，有两个事件（启动和暂定）可供我们使用。
  </p>
</div>


<p><span style="color: #339966;"><a href="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130616-10.png"><img class=" wp-image-1372 alignright" alt="QQ20130616-10" src="http://beyondvincent.com/wp-content/uploads/2013/06/QQ20130616-10.png" width="247" height="211" /></a>UIDynamicBehavior：<span style="color: #333333;">主要用来描述动力的行为。在iOS7中，默认提供了如下动力行为：</span></span></p>

<ul>
<li>UIAttachmentBehavior</li>
<li>UICollisionBehavior</li>
<li>UIDynamicItemBehavior</li>
<li>UIGravityBehavior</li>
<li>UIPushBehavior</li>
<li>UISnapBehavior objects</li>
</ul>


<p>动力行为可以在任意时间内进行添加或移除。另外动力行为可以是组合的，也可以被继承。</p>

<p>注意：这些动力行为是在二维空间进行的。</p>

<p><span style="color: #339966;">Reference View</span>：该用是用来初始化Animator用的，它的作用是给动力行为提供坐标系。</p>

<p><span style="color: #339966;">View</span>：在UIKit动力中，又称为动力项(dynamic item)。动力项是遵循UIDynamicItem协议的任意对象（可以是SDK中默认提供的，或者开发者自定义的）。在iOS7 beta中，View已经遵循了该协议，所以一般也会将View当做动力项——动力行为实际针对的对象。</p>

<h2><span style="color: #339966;"><strong>代码示例</strong></span></h2>

<p>下面笔者就通过一个例子，演示如何对一个view施加重力行为(UIGravityBehavior)。</p>

<p>上面介绍了一大堆，实际使用过程可能没那么复杂，不过原理才是最重要的。</p>

<p>新建一个Single View Application模板工程：BVGravityBehavior，在工程中，有如下属性：</p>

<pre class="wp-code-highlight prettyprint linenums:1">@property (nonatomic, weak) IBOutlet UIImageView *square1;
@property (nonatomic) UIDynamicAnimator* animator;</pre>


<p>另外还有两个方法：</p>

<pre class="wp-code-highlight prettyprint linenums:1">// 开始重力行为
- (IBAction)startGravity:(id)sender
{
    self.animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
    UIGravityBehavior* gravityBeahvior = [[UIGravityBehavior alloc] initWithItems:@[self.square1]];
    [self.animator addBehavior:gravityBeahvior];
}</pre>




<pre class="wp-code-highlight prettyprint linenums:1">// 停止重力行为
- (IBAction)stopGravity:(id)sender
{
    [self.animator removeAllBehaviors];
}</pre>


<p>运行程序，效果如下（如图没看到gif动画效果，点击下图，在新窗口中可以看到效果）：</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/1.gif" target="_blank"><img class="alignnone size-full wp-image-1383" alt="1" src="http://beyondvincent.com/wp-content/uploads/2013/06/1.gif" width="570" height="700" /></a></p>

<p>&nbsp;</p>

<p>也可以停止当前的动力行为：在重力行为运行过程中，如果点击停止，就可以停止重力行为，view的状态为停止前的状态。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/06/2.gif" target="_blank"><img class="alignnone size-full wp-image-1384" alt="2" src="http://beyondvincent.com/wp-content/uploads/2013/06/2.gif" width="572" height="706" /></a></p>

<p>&nbsp;</p>

<h2><strong><span style="color: #339966;">代码下载</span></strong></h2>

<p><a href="https://github.com/BeyondVincent/iOS7-new-feature/tree/master/code/UIDynamic/BVGravityBehavior" target="_blank"><img class="alignnone size-full wp-image-561" alt="代码下载" src="http://beyondvincent.com/wp-content/uploads/2013/05/5555.png" width="150" height="150" /></a></p>

<p>&nbsp;</p>

<h2><span style="color: #339966;">小结</span></h2>

<p>本文对UIKit动力做了一个入门级别的介绍，并给出了一个小示例，演示了如何给view添加一个重力行为。在下一篇文章中，笔者将继续介绍UIKit动力。</p>

<p>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_<strong>_</strong>_</p>

<h2><span style="color: #339966;"><strong>强烈推荐</strong></span></h2>

<p>来自唐巧的一个微信公众账号：<span style="color: #339966;">iosDevTips</span>——基本每天都会有关于iOS开发的精彩内容分享。<br/>
来自唐巧的一个Google Group讨论组：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="https://groups.google.com/forum/#!forum/iosdevtips" target="_blank"><span style="color: #339966; text-decoration: underline;">iosDevTips</span></a></span></span></p>

<h2><span style="color: #339966;"><strong>新特征汇总更新通知方式</strong></span></h2>

<p>有新的内容我会通过下面的方式进行通知，欢迎关注：<br/>
新浪微博：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://www.weibo.com/beyondvincent" target="_blank"><span style="color: #339966; text-decoration: underline;">beyondvincent</span></a></strong></span></span><br/>
腾讯微博：<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><strong><a href="http://t.qq.com/beyondvincent" target="_blank"><span style="color: #339966; text-decoration: underline;">beyondvincent</span></a></strong></span></span><br/>
微信公众账号：<strong>破船之家</strong><br/>
<a href="http://beyondvincent.com/wp-content/uploads/2013/03/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7-%E7%A0%B4%E8%88%B9%E4%B9%8B%E5%AE%B6.jpg"><img alt="微信公众账号-破船之家" src="http://beyondvincent.com/wp-content/uploads/2013/03/微信公众账号-破船之家-150x150.jpg" width="150" height="150" /></a></p>

<div>
</div>




<div>
  本文由<span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></span></span>原创●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-06-15</time>
</div>



]]></content>
  </entry>
  
</feed>
